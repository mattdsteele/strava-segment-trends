// tslint:disable
/**
 * Strava API v3
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * A set of rolled-up statistics and totals for an athlete
 * @export
 * @interface ActivityStats
 */
export interface ActivityStats {
    /**
     * The longest distance ridden by the athlete.
     * @type {number}
     * @memberof ActivityStats
     */
    biggest_ride_distance?: number;
    /**
     * The highest climb ridden by the athlete.
     * @type {number}
     * @memberof ActivityStats
     */
    biggest_climb_elevation_gain?: number;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    recent_ride_totals?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    recent_run_totals?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    recent_swim_totals?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    ytd_ride_totals?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    ytd_run_totals?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    ytd_swim_totals?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    all_ride_totals?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    all_run_totals?: ActivityTotal;
    /**
     * 
     * @type {ActivityTotal}
     * @memberof ActivityStats
     */
    all_swim_totals?: ActivityTotal;
}
/**
 * A roll-up of metrics pertaining to a set of activities. Values are in seconds and meters.
 * @export
 * @interface ActivityTotal
 */
export interface ActivityTotal {
    /**
     * The number of activities considered in this total.
     * @type {number}
     * @memberof ActivityTotal
     */
    count?: number;
    /**
     * The total distance covered by the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    distance?: number;
    /**
     * The total moving time of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    moving_time?: number;
    /**
     * The total elapsed time of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    elapsed_time?: number;
    /**
     * The total elevation gain of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    elevation_gain?: number;
    /**
     * The total number of achievements of the considered activities.
     * @type {number}
     * @memberof ActivityTotal
     */
    achievement_count?: number;
}
/**
 * An enumeration of the types an activity may have.
 * @export
 * @enum {string}
 */
export enum ActivityType {
    AlpineSki = 'AlpineSki',
    BackcountrySki = 'BackcountrySki',
    Canoeing = 'Canoeing',
    Crossfit = 'Crossfit',
    EBikeRide = 'EBikeRide',
    Elliptical = 'Elliptical',
    Golf = 'Golf',
    Handcycle = 'Handcycle',
    Hike = 'Hike',
    IceSkate = 'IceSkate',
    InlineSkate = 'InlineSkate',
    Kayaking = 'Kayaking',
    Kitesurf = 'Kitesurf',
    NordicSki = 'NordicSki',
    Ride = 'Ride',
    RockClimbing = 'RockClimbing',
    RollerSki = 'RollerSki',
    Rowing = 'Rowing',
    Run = 'Run',
    Sail = 'Sail',
    Skateboard = 'Skateboard',
    Snowboard = 'Snowboard',
    Snowshoe = 'Snowshoe',
    Soccer = 'Soccer',
    StairStepper = 'StairStepper',
    StandUpPaddling = 'StandUpPaddling',
    Surfing = 'Surfing',
    Swim = 'Swim',
    Velomobile = 'Velomobile',
    VirtualRide = 'VirtualRide',
    VirtualRun = 'VirtualRun',
    Walk = 'Walk',
    WeightTraining = 'WeightTraining',
    Wheelchair = 'Wheelchair',
    Windsurf = 'Windsurf',
    Workout = 'Workout',
    Yoga = 'Yoga'
}

/**
 * 
 * @export
 * @interface ActivityZone
 */
export interface ActivityZone {
    /**
     * 
     * @type {number}
     * @memberof ActivityZone
     */
    score?: number;
    /**
     * Stores the exclusive ranges representing zones and the time spent in each.
     * @type {Array<TimedZoneRange>}
     * @memberof ActivityZone
     */
    distribution_buckets?: Array<TimedZoneRange>;
    /**
     * 
     * @type {string}
     * @memberof ActivityZone
     */
    type?: ActivityZoneTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ActivityZone
     */
    sensor_based?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ActivityZone
     */
    points?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ActivityZone
     */
    custom_zones?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ActivityZone
     */
    max?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum ActivityZoneTypeEnum {
    Heartrate = 'heartrate',
    Power = 'power'
}

/**
 * 
 * @export
 * @interface AltitudeStream
 */
export interface AltitudeStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof AltitudeStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof AltitudeStream
     */
    resolution?: AltitudeStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof AltitudeStream
     */
    series_type?: AltitudeStreamSeriesTypeEnum;
    /**
     * The sequence of altitude values for this stream, in meters
     * @type {Array<number>}
     * @memberof AltitudeStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum AltitudeStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum AltitudeStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface AltitudeStreamAllOf
 */
export interface AltitudeStreamAllOf {
    /**
     * The sequence of altitude values for this stream, in meters
     * @type {Array<number>}
     * @memberof AltitudeStreamAllOf
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface BaseStream
 */
export interface BaseStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof BaseStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof BaseStream
     */
    resolution?: BaseStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof BaseStream
     */
    series_type?: BaseStreamSeriesTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum BaseStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum BaseStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface CadenceStream
 */
export interface CadenceStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof CadenceStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof CadenceStream
     */
    resolution?: CadenceStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof CadenceStream
     */
    series_type?: CadenceStreamSeriesTypeEnum;
    /**
     * The sequence of cadence values for this stream, in rotations per minute
     * @type {Array<number>}
     * @memberof CadenceStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum CadenceStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum CadenceStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface CadenceStreamAllOf
 */
export interface CadenceStreamAllOf {
    /**
     * The sequence of cadence values for this stream, in rotations per minute
     * @type {Array<number>}
     * @memberof CadenceStreamAllOf
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface Comment
 */
export interface Comment {
    /**
     * The unique identifier of this comment
     * @type {number}
     * @memberof Comment
     */
    id?: number;
    /**
     * The identifier of the activity this comment is related to
     * @type {number}
     * @memberof Comment
     */
    activity_id?: number;
    /**
     * The content of the comment
     * @type {string}
     * @memberof Comment
     */
    text?: string;
    /**
     * 
     * @type {SummaryAthlete}
     * @memberof Comment
     */
    athlete?: SummaryAthlete;
    /**
     * The time at which this comment was created.
     * @type {string}
     * @memberof Comment
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface DetailedActivity
 */
export interface DetailedActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof DetailedActivity
     */
    id?: number;
    /**
     * The identifier provided at upload time
     * @type {string}
     * @memberof DetailedActivity
     */
    external_id?: string;
    /**
     * The identifier of the upload that resulted in this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    upload_id?: number;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof DetailedActivity
     */
    athlete?: MetaAthlete;
    /**
     * The name of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    name?: string;
    /**
     * The activity\'s distance, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    distance?: number;
    /**
     * The activity\'s moving time, in seconds
     * @type {number}
     * @memberof DetailedActivity
     */
    moving_time?: number;
    /**
     * The activity\'s elapsed time, in seconds
     * @type {number}
     * @memberof DetailedActivity
     */
    elapsed_time?: number;
    /**
     * The activity\'s total elevation gain.
     * @type {number}
     * @memberof DetailedActivity
     */
    total_elevation_gain?: number;
    /**
     * The activity\'s highest elevation, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    elev_high?: number;
    /**
     * The activity\'s lowest elevation, in meters
     * @type {number}
     * @memberof DetailedActivity
     */
    elev_low?: number;
    /**
     * 
     * @type {ActivityType}
     * @memberof DetailedActivity
     */
    type?: ActivityType;
    /**
     * The time at which the activity was started.
     * @type {string}
     * @memberof DetailedActivity
     */
    start_date?: string;
    /**
     * The time at which the activity was started in the local timezone.
     * @type {string}
     * @memberof DetailedActivity
     */
    start_date_local?: string;
    /**
     * The timezone of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    timezone?: string;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof DetailedActivity
     */
    start_latlng?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof DetailedActivity
     */
    end_latlng?: Array<number>;
    /**
     * The number of achievements gained during this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    achievement_count?: number;
    /**
     * The number of kudos given for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    kudos_count?: number;
    /**
     * The number of comments for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    comment_count?: number;
    /**
     * The number of athletes for taking part in a group activity
     * @type {number}
     * @memberof DetailedActivity
     */
    athlete_count?: number;
    /**
     * The number of Instagram photos for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    photo_count?: number;
    /**
     * The number of Instagram and Strava photos for this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    total_photo_count?: number;
    /**
     * 
     * @type {PolylineMap}
     * @memberof DetailedActivity
     */
    map?: PolylineMap;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof DetailedActivity
     */
    trainer?: boolean;
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof DetailedActivity
     */
    commute?: boolean;
    /**
     * Whether this activity was created manually
     * @type {boolean}
     * @memberof DetailedActivity
     */
    manual?: boolean;
    /**
     * Whether this activity is private
     * @type {boolean}
     * @memberof DetailedActivity
     */
    _private?: boolean;
    /**
     * Whether this activity is flagged
     * @type {boolean}
     * @memberof DetailedActivity
     */
    flagged?: boolean;
    /**
     * The activity\'s workout type
     * @type {number}
     * @memberof DetailedActivity
     */
    workout_type?: number;
    /**
     * The unique identifier of the upload in string format
     * @type {string}
     * @memberof DetailedActivity
     */
    upload_id_str?: string;
    /**
     * The activity\'s average speed, in meters per second
     * @type {number}
     * @memberof DetailedActivity
     */
    average_speed?: number;
    /**
     * The activity\'s max speed, in meters per second
     * @type {number}
     * @memberof DetailedActivity
     */
    max_speed?: number;
    /**
     * Whether the logged-in athlete has kudoed this activity
     * @type {boolean}
     * @memberof DetailedActivity
     */
    has_kudoed?: boolean;
    /**
     * The id of the gear for the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    gear_id?: string;
    /**
     * The total work done in kilojoules during this activity. Rides only
     * @type {number}
     * @memberof DetailedActivity
     */
    kilojoules?: number;
    /**
     * Average power output in watts during this activity. Rides only
     * @type {number}
     * @memberof DetailedActivity
     */
    average_watts?: number;
    /**
     * Whether the watts are from a power meter, false if estimated
     * @type {boolean}
     * @memberof DetailedActivity
     */
    device_watts?: boolean;
    /**
     * Rides with power meter data only
     * @type {number}
     * @memberof DetailedActivity
     */
    max_watts?: number;
    /**
     * Similar to Normalized Power. Rides with power meter data only
     * @type {number}
     * @memberof DetailedActivity
     */
    weighted_average_watts?: number;
    /**
     * The description of the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    description?: string;
    /**
     * 
     * @type {PhotosSummary}
     * @memberof DetailedActivity
     */
    photos?: PhotosSummary;
    /**
     * 
     * @type {SummaryGear}
     * @memberof DetailedActivity
     */
    gear?: SummaryGear;
    /**
     * The number of kilocalories consumed during this activity
     * @type {number}
     * @memberof DetailedActivity
     */
    calories?: number;
    /**
     * 
     * @type {Array<DetailedSegmentEffort>}
     * @memberof DetailedActivity
     */
    segment_efforts?: Array<DetailedSegmentEffort>;
    /**
     * The name of the device used to record the activity
     * @type {string}
     * @memberof DetailedActivity
     */
    device_name?: string;
    /**
     * The token used to embed a Strava activity
     * @type {string}
     * @memberof DetailedActivity
     */
    embed_token?: string;
    /**
     * The splits of this activity in metric units (for runs)
     * @type {Array<Split>}
     * @memberof DetailedActivity
     */
    splits_metric?: Array<Split>;
    /**
     * The splits of this activity in imperial units (for runs)
     * @type {Array<Split>}
     * @memberof DetailedActivity
     */
    splits_standard?: Array<Split>;
    /**
     * 
     * @type {Array<Lap>}
     * @memberof DetailedActivity
     */
    laps?: Array<Lap>;
    /**
     * 
     * @type {Array<DetailedSegmentEffort>}
     * @memberof DetailedActivity
     */
    best_efforts?: Array<DetailedSegmentEffort>;
}
/**
 * 
 * @export
 * @interface DetailedActivityAllOf
 */
export interface DetailedActivityAllOf {
    /**
     * The description of the activity
     * @type {string}
     * @memberof DetailedActivityAllOf
     */
    description?: string;
    /**
     * 
     * @type {PhotosSummary}
     * @memberof DetailedActivityAllOf
     */
    photos?: PhotosSummary;
    /**
     * 
     * @type {SummaryGear}
     * @memberof DetailedActivityAllOf
     */
    gear?: SummaryGear;
    /**
     * The number of kilocalories consumed during this activity
     * @type {number}
     * @memberof DetailedActivityAllOf
     */
    calories?: number;
    /**
     * 
     * @type {Array<DetailedSegmentEffort>}
     * @memberof DetailedActivityAllOf
     */
    segment_efforts?: Array<DetailedSegmentEffort>;
    /**
     * The name of the device used to record the activity
     * @type {string}
     * @memberof DetailedActivityAllOf
     */
    device_name?: string;
    /**
     * The token used to embed a Strava activity
     * @type {string}
     * @memberof DetailedActivityAllOf
     */
    embed_token?: string;
    /**
     * The splits of this activity in metric units (for runs)
     * @type {Array<Split>}
     * @memberof DetailedActivityAllOf
     */
    splits_metric?: Array<Split>;
    /**
     * The splits of this activity in imperial units (for runs)
     * @type {Array<Split>}
     * @memberof DetailedActivityAllOf
     */
    splits_standard?: Array<Split>;
    /**
     * 
     * @type {Array<Lap>}
     * @memberof DetailedActivityAllOf
     */
    laps?: Array<Lap>;
    /**
     * 
     * @type {Array<DetailedSegmentEffort>}
     * @memberof DetailedActivityAllOf
     */
    best_efforts?: Array<DetailedSegmentEffort>;
}
/**
 * 
 * @export
 * @interface DetailedAthlete
 */
export interface DetailedAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof DetailedAthlete
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof DetailedAthlete
     */
    resource_state?: number;
    /**
     * The athlete\'s first name.
     * @type {string}
     * @memberof DetailedAthlete
     */
    firstname?: string;
    /**
     * The athlete\'s last name.
     * @type {string}
     * @memberof DetailedAthlete
     */
    lastname?: string;
    /**
     * URL to a 62x62 pixel profile picture.
     * @type {string}
     * @memberof DetailedAthlete
     */
    profile_medium?: string;
    /**
     * URL to a 124x124 pixel profile picture.
     * @type {string}
     * @memberof DetailedAthlete
     */
    profile?: string;
    /**
     * The athlete\'s city.
     * @type {string}
     * @memberof DetailedAthlete
     */
    city?: string;
    /**
     * The athlete\'s state or geographical region.
     * @type {string}
     * @memberof DetailedAthlete
     */
    state?: string;
    /**
     * The athlete\'s country.
     * @type {string}
     * @memberof DetailedAthlete
     */
    country?: string;
    /**
     * The athlete\'s sex.
     * @type {string}
     * @memberof DetailedAthlete
     */
    sex?: DetailedAthleteSexEnum;
    /**
     * Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof DetailedAthlete
     */
    premium?: boolean;
    /**
     * Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof DetailedAthlete
     */
    summit?: boolean;
    /**
     * The time at which the athlete was created.
     * @type {string}
     * @memberof DetailedAthlete
     */
    created_at?: string;
    /**
     * The time at which the athlete was last updated.
     * @type {string}
     * @memberof DetailedAthlete
     */
    updated_at?: string;
    /**
     * The athlete\'s follower count.
     * @type {number}
     * @memberof DetailedAthlete
     */
    follower_count?: number;
    /**
     * The athlete\'s friend count.
     * @type {number}
     * @memberof DetailedAthlete
     */
    friend_count?: number;
    /**
     * The athlete\'s preferred unit system.
     * @type {string}
     * @memberof DetailedAthlete
     */
    measurement_preference?: DetailedAthleteMeasurementPreferenceEnum;
    /**
     * The athlete\'s FTP (Functional Threshold Power).
     * @type {number}
     * @memberof DetailedAthlete
     */
    ftp?: number;
    /**
     * The athlete\'s weight.
     * @type {number}
     * @memberof DetailedAthlete
     */
    weight?: number;
    /**
     * The athlete\'s clubs.
     * @type {Array<SummaryClub>}
     * @memberof DetailedAthlete
     */
    clubs?: Array<SummaryClub>;
    /**
     * The athlete\'s bikes.
     * @type {Array<SummaryGear>}
     * @memberof DetailedAthlete
     */
    bikes?: Array<SummaryGear>;
    /**
     * The athlete\'s shoes.
     * @type {Array<SummaryGear>}
     * @memberof DetailedAthlete
     */
    shoes?: Array<SummaryGear>;
}

/**
    * @export
    * @enum {string}
    */
export enum DetailedAthleteSexEnum {
    M = 'M',
    F = 'F'
}
/**
    * @export
    * @enum {string}
    */
export enum DetailedAthleteMeasurementPreferenceEnum {
    Feet = 'feet',
    Meters = 'meters'
}

/**
 * 
 * @export
 * @interface DetailedAthleteAllOf
 */
export interface DetailedAthleteAllOf {
    /**
     * The athlete\'s follower count.
     * @type {number}
     * @memberof DetailedAthleteAllOf
     */
    follower_count?: number;
    /**
     * The athlete\'s friend count.
     * @type {number}
     * @memberof DetailedAthleteAllOf
     */
    friend_count?: number;
    /**
     * The athlete\'s preferred unit system.
     * @type {string}
     * @memberof DetailedAthleteAllOf
     */
    measurement_preference?: DetailedAthleteAllOfMeasurementPreferenceEnum;
    /**
     * The athlete\'s FTP (Functional Threshold Power).
     * @type {number}
     * @memberof DetailedAthleteAllOf
     */
    ftp?: number;
    /**
     * The athlete\'s weight.
     * @type {number}
     * @memberof DetailedAthleteAllOf
     */
    weight?: number;
    /**
     * The athlete\'s clubs.
     * @type {Array<SummaryClub>}
     * @memberof DetailedAthleteAllOf
     */
    clubs?: Array<SummaryClub>;
    /**
     * The athlete\'s bikes.
     * @type {Array<SummaryGear>}
     * @memberof DetailedAthleteAllOf
     */
    bikes?: Array<SummaryGear>;
    /**
     * The athlete\'s shoes.
     * @type {Array<SummaryGear>}
     * @memberof DetailedAthleteAllOf
     */
    shoes?: Array<SummaryGear>;
}

/**
    * @export
    * @enum {string}
    */
export enum DetailedAthleteAllOfMeasurementPreferenceEnum {
    Feet = 'feet',
    Meters = 'meters'
}

/**
 * 
 * @export
 * @interface DetailedClub
 */
export interface DetailedClub {
    /**
     * The club\'s unique identifier.
     * @type {number}
     * @memberof DetailedClub
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof DetailedClub
     */
    resource_state?: number;
    /**
     * The club\'s name.
     * @type {string}
     * @memberof DetailedClub
     */
    name?: string;
    /**
     * URL to a 60x60 pixel profile picture.
     * @type {string}
     * @memberof DetailedClub
     */
    profile_medium?: string;
    /**
     * URL to a ~1185x580 pixel cover photo.
     * @type {string}
     * @memberof DetailedClub
     */
    cover_photo?: string;
    /**
     * URL to a ~360x176  pixel cover photo.
     * @type {string}
     * @memberof DetailedClub
     */
    cover_photo_small?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailedClub
     */
    sport_type?: DetailedClubSportTypeEnum;
    /**
     * The club\'s city.
     * @type {string}
     * @memberof DetailedClub
     */
    city?: string;
    /**
     * The club\'s state or geographical region.
     * @type {string}
     * @memberof DetailedClub
     */
    state?: string;
    /**
     * The club\'s country.
     * @type {string}
     * @memberof DetailedClub
     */
    country?: string;
    /**
     * Whether the club is private.
     * @type {boolean}
     * @memberof DetailedClub
     */
    _private?: boolean;
    /**
     * The club\'s member count.
     * @type {number}
     * @memberof DetailedClub
     */
    member_count?: number;
    /**
     * Whether the club is featured or not.
     * @type {boolean}
     * @memberof DetailedClub
     */
    featured?: boolean;
    /**
     * Whether the club is verified or not.
     * @type {boolean}
     * @memberof DetailedClub
     */
    verified?: boolean;
    /**
     * The club\'s vanity URL.
     * @type {string}
     * @memberof DetailedClub
     */
    url?: string;
    /**
     * The membership status of the logged-in athlete.
     * @type {string}
     * @memberof DetailedClub
     */
    membership?: DetailedClubMembershipEnum;
    /**
     * Whether the currently logged-in athlete is an administrator of this club.
     * @type {boolean}
     * @memberof DetailedClub
     */
    admin?: boolean;
    /**
     * Whether the currently logged-in athlete is the owner of this club.
     * @type {boolean}
     * @memberof DetailedClub
     */
    owner?: boolean;
    /**
     * The number of athletes in the club that the logged-in athlete follows.
     * @type {number}
     * @memberof DetailedClub
     */
    following_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DetailedClubSportTypeEnum {
    Cycling = 'cycling',
    Running = 'running',
    Triathlon = 'triathlon',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum DetailedClubMembershipEnum {
    Member = 'member',
    Pending = 'pending'
}

/**
 * 
 * @export
 * @interface DetailedClubAllOf
 */
export interface DetailedClubAllOf {
    /**
     * The membership status of the logged-in athlete.
     * @type {string}
     * @memberof DetailedClubAllOf
     */
    membership?: DetailedClubAllOfMembershipEnum;
    /**
     * Whether the currently logged-in athlete is an administrator of this club.
     * @type {boolean}
     * @memberof DetailedClubAllOf
     */
    admin?: boolean;
    /**
     * Whether the currently logged-in athlete is the owner of this club.
     * @type {boolean}
     * @memberof DetailedClubAllOf
     */
    owner?: boolean;
    /**
     * The number of athletes in the club that the logged-in athlete follows.
     * @type {number}
     * @memberof DetailedClubAllOf
     */
    following_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DetailedClubAllOfMembershipEnum {
    Member = 'member',
    Pending = 'pending'
}

/**
 * 
 * @export
 * @interface DetailedGear
 */
export interface DetailedGear {
    /**
     * The gear\'s unique identifier.
     * @type {string}
     * @memberof DetailedGear
     */
    id?: string;
    /**
     * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof DetailedGear
     */
    resource_state?: number;
    /**
     * Whether this gear\'s is the owner\'s default one.
     * @type {boolean}
     * @memberof DetailedGear
     */
    primary?: boolean;
    /**
     * The gear\'s name.
     * @type {string}
     * @memberof DetailedGear
     */
    name?: string;
    /**
     * The distance logged with this gear.
     * @type {number}
     * @memberof DetailedGear
     */
    distance?: number;
    /**
     * The gear\'s brand name.
     * @type {string}
     * @memberof DetailedGear
     */
    brand_name?: string;
    /**
     * The gear\'s model name.
     * @type {string}
     * @memberof DetailedGear
     */
    model_name?: string;
    /**
     * The gear\'s frame type (bike only).
     * @type {number}
     * @memberof DetailedGear
     */
    frame_type?: number;
    /**
     * The gear\'s description.
     * @type {string}
     * @memberof DetailedGear
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface DetailedGearAllOf
 */
export interface DetailedGearAllOf {
    /**
     * The gear\'s brand name.
     * @type {string}
     * @memberof DetailedGearAllOf
     */
    brand_name?: string;
    /**
     * The gear\'s model name.
     * @type {string}
     * @memberof DetailedGearAllOf
     */
    model_name?: string;
    /**
     * The gear\'s frame type (bike only).
     * @type {number}
     * @memberof DetailedGearAllOf
     */
    frame_type?: number;
    /**
     * The gear\'s description.
     * @type {string}
     * @memberof DetailedGearAllOf
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface DetailedSegment
 */
export interface DetailedSegment {
    /**
     * The unique identifier of this segment
     * @type {number}
     * @memberof DetailedSegment
     */
    id?: number;
    /**
     * The name of this segment
     * @type {string}
     * @memberof DetailedSegment
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DetailedSegment
     */
    activity_type?: DetailedSegmentActivityTypeEnum;
    /**
     * The segment\'s distance, in meters
     * @type {number}
     * @memberof DetailedSegment
     */
    distance?: number;
    /**
     * The segment\'s average grade, in percents
     * @type {number}
     * @memberof DetailedSegment
     */
    average_grade?: number;
    /**
     * The segments\'s maximum grade, in percents
     * @type {number}
     * @memberof DetailedSegment
     */
    maximum_grade?: number;
    /**
     * The segments\'s highest elevation, in meters
     * @type {number}
     * @memberof DetailedSegment
     */
    elevation_high?: number;
    /**
     * The segments\'s lowest elevation, in meters
     * @type {number}
     * @memberof DetailedSegment
     */
    elevation_low?: number;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof DetailedSegment
     */
    start_latlng?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof DetailedSegment
     */
    end_latlng?: Array<number>;
    /**
     * The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category.
     * @type {number}
     * @memberof DetailedSegment
     */
    climb_category?: number;
    /**
     * The segments\'s city.
     * @type {string}
     * @memberof DetailedSegment
     */
    city?: string;
    /**
     * The segments\'s state or geographical region.
     * @type {string}
     * @memberof DetailedSegment
     */
    state?: string;
    /**
     * The segment\'s country.
     * @type {string}
     * @memberof DetailedSegment
     */
    country?: string;
    /**
     * Whether this segment is private.
     * @type {boolean}
     * @memberof DetailedSegment
     */
    _private?: boolean;
    /**
     * 
     * @type {SummarySegmentEffort}
     * @memberof DetailedSegment
     */
    athlete_pr_effort?: SummarySegmentEffort;
    /**
     * The time at which the segment was created.
     * @type {string}
     * @memberof DetailedSegment
     */
    created_at?: string;
    /**
     * The time at which the segment was last updated.
     * @type {string}
     * @memberof DetailedSegment
     */
    updated_at?: string;
    /**
     * The segment\'s total elevation gain.
     * @type {number}
     * @memberof DetailedSegment
     */
    total_elevation_gain?: number;
    /**
     * 
     * @type {PolylineMap}
     * @memberof DetailedSegment
     */
    map?: PolylineMap;
    /**
     * The total number of efforts for this segment
     * @type {number}
     * @memberof DetailedSegment
     */
    effort_count?: number;
    /**
     * The number of unique athletes who have an effort for this segment
     * @type {number}
     * @memberof DetailedSegment
     */
    athlete_count?: number;
    /**
     * Whether this segment is considered hazardous
     * @type {boolean}
     * @memberof DetailedSegment
     */
    hazardous?: boolean;
    /**
     * The number of stars for this segment
     * @type {number}
     * @memberof DetailedSegment
     */
    star_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum DetailedSegmentActivityTypeEnum {
    Ride = 'Ride',
    Run = 'Run'
}

/**
 * 
 * @export
 * @interface DetailedSegmentAllOf
 */
export interface DetailedSegmentAllOf {
    /**
     * The time at which the segment was created.
     * @type {string}
     * @memberof DetailedSegmentAllOf
     */
    created_at?: string;
    /**
     * The time at which the segment was last updated.
     * @type {string}
     * @memberof DetailedSegmentAllOf
     */
    updated_at?: string;
    /**
     * The segment\'s total elevation gain.
     * @type {number}
     * @memberof DetailedSegmentAllOf
     */
    total_elevation_gain?: number;
    /**
     * 
     * @type {PolylineMap}
     * @memberof DetailedSegmentAllOf
     */
    map?: PolylineMap;
    /**
     * The total number of efforts for this segment
     * @type {number}
     * @memberof DetailedSegmentAllOf
     */
    effort_count?: number;
    /**
     * The number of unique athletes who have an effort for this segment
     * @type {number}
     * @memberof DetailedSegmentAllOf
     */
    athlete_count?: number;
    /**
     * Whether this segment is considered hazardous
     * @type {boolean}
     * @memberof DetailedSegmentAllOf
     */
    hazardous?: boolean;
    /**
     * The number of stars for this segment
     * @type {number}
     * @memberof DetailedSegmentAllOf
     */
    star_count?: number;
}
/**
 * 
 * @export
 * @interface DetailedSegmentEffort
 */
export interface DetailedSegmentEffort {
    /**
     * The unique identifier of this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    id?: number;
    /**
     * The effort\'s elapsed time
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    elapsed_time?: number;
    /**
     * The time at which the effort was started.
     * @type {string}
     * @memberof DetailedSegmentEffort
     */
    start_date?: string;
    /**
     * The time at which the effort was started in the local timezone.
     * @type {string}
     * @memberof DetailedSegmentEffort
     */
    start_date_local?: string;
    /**
     * The effort\'s distance in meters
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    distance?: number;
    /**
     * Whether this effort is the current best on the leaderboard
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    is_kom?: boolean;
    /**
     * The name of the segment on which this effort was performed
     * @type {string}
     * @memberof DetailedSegmentEffort
     */
    name?: string;
    /**
     * 
     * @type {MetaActivity}
     * @memberof DetailedSegmentEffort
     */
    activity?: MetaActivity;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof DetailedSegmentEffort
     */
    athlete?: MetaAthlete;
    /**
     * The effort\'s moving time
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    moving_time?: number;
    /**
     * The start index of this effort in its activity\'s stream
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    start_index?: number;
    /**
     * The end index of this effort in its activity\'s stream
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    end_index?: number;
    /**
     * The effort\'s average cadence
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    average_cadence?: number;
    /**
     * The average wattage of this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    average_watts?: number;
    /**
     * For riding efforts, whether the wattage was reported by a dedicated recording device
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    device_watts?: boolean;
    /**
     * The heart heart rate of the athlete during this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    average_heartrate?: number;
    /**
     * The maximum heart rate of the athlete during this effort
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    max_heartrate?: number;
    /**
     * 
     * @type {SummarySegment}
     * @memberof DetailedSegmentEffort
     */
    segment?: SummarySegment;
    /**
     * The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    kom_rank?: number;
    /**
     * The rank of the effort on the athlete\'s leaderboard if it belongs in the top 3 at the time of upload
     * @type {number}
     * @memberof DetailedSegmentEffort
     */
    pr_rank?: number;
    /**
     * Whether this effort should be hidden when viewed within an activity
     * @type {boolean}
     * @memberof DetailedSegmentEffort
     */
    hidden?: boolean;
}
/**
 * 
 * @export
 * @interface DetailedSegmentEffortAllOf
 */
export interface DetailedSegmentEffortAllOf {
    /**
     * The name of the segment on which this effort was performed
     * @type {string}
     * @memberof DetailedSegmentEffortAllOf
     */
    name?: string;
    /**
     * 
     * @type {MetaActivity}
     * @memberof DetailedSegmentEffortAllOf
     */
    activity?: MetaActivity;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof DetailedSegmentEffortAllOf
     */
    athlete?: MetaAthlete;
    /**
     * The effort\'s moving time
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    moving_time?: number;
    /**
     * The start index of this effort in its activity\'s stream
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    start_index?: number;
    /**
     * The end index of this effort in its activity\'s stream
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    end_index?: number;
    /**
     * The effort\'s average cadence
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    average_cadence?: number;
    /**
     * The average wattage of this effort
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    average_watts?: number;
    /**
     * For riding efforts, whether the wattage was reported by a dedicated recording device
     * @type {boolean}
     * @memberof DetailedSegmentEffortAllOf
     */
    device_watts?: boolean;
    /**
     * The heart heart rate of the athlete during this effort
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    average_heartrate?: number;
    /**
     * The maximum heart rate of the athlete during this effort
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    max_heartrate?: number;
    /**
     * 
     * @type {SummarySegment}
     * @memberof DetailedSegmentEffortAllOf
     */
    segment?: SummarySegment;
    /**
     * The rank of the effort on the global leaderboard if it belongs in the top 10 at the time of upload
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    kom_rank?: number;
    /**
     * The rank of the effort on the athlete\'s leaderboard if it belongs in the top 3 at the time of upload
     * @type {number}
     * @memberof DetailedSegmentEffortAllOf
     */
    pr_rank?: number;
    /**
     * Whether this effort should be hidden when viewed within an activity
     * @type {boolean}
     * @memberof DetailedSegmentEffortAllOf
     */
    hidden?: boolean;
}
/**
 * 
 * @export
 * @interface DistanceStream
 */
export interface DistanceStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof DistanceStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof DistanceStream
     */
    resolution?: DistanceStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof DistanceStream
     */
    series_type?: DistanceStreamSeriesTypeEnum;
    /**
     * The sequence of distance values for this stream, in meters
     * @type {Array<number>}
     * @memberof DistanceStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum DistanceStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum DistanceStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface DistanceStreamAllOf
 */
export interface DistanceStreamAllOf {
    /**
     * The sequence of distance values for this stream, in meters
     * @type {Array<number>}
     * @memberof DistanceStreamAllOf
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface ExplorerResponse
 */
export interface ExplorerResponse {
    /**
     * The set of segments matching an explorer request
     * @type {Array<ExplorerSegment>}
     * @memberof ExplorerResponse
     */
    segments?: Array<ExplorerSegment>;
}
/**
 * 
 * @export
 * @interface ExplorerSegment
 */
export interface ExplorerSegment {
    /**
     * The unique identifier of this segment
     * @type {number}
     * @memberof ExplorerSegment
     */
    id?: number;
    /**
     * The name of this segment
     * @type {string}
     * @memberof ExplorerSegment
     */
    name?: string;
    /**
     * The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category. If climb_category = 5, climb_category_desc = HC. If climb_category = 2, climb_category_desc = 3.
     * @type {number}
     * @memberof ExplorerSegment
     */
    climb_category?: number;
    /**
     * The description for the category of the climb
     * @type {string}
     * @memberof ExplorerSegment
     */
    climb_category_desc?: ExplorerSegmentClimbCategoryDescEnum;
    /**
     * The segment\'s average grade, in percents
     * @type {number}
     * @memberof ExplorerSegment
     */
    avg_grade?: number;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof ExplorerSegment
     */
    start_latlng?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof ExplorerSegment
     */
    end_latlng?: Array<number>;
    /**
     * The segments\'s evelation difference, in meters
     * @type {number}
     * @memberof ExplorerSegment
     */
    elev_difference?: number;
    /**
     * The segment\'s distance, in meters
     * @type {number}
     * @memberof ExplorerSegment
     */
    distance?: number;
    /**
     * The polyline of the segment
     * @type {string}
     * @memberof ExplorerSegment
     */
    points?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ExplorerSegmentClimbCategoryDescEnum {
    NC = 'NC',
    _4 = '4',
    _3 = '3',
    _2 = '2',
    _1 = '1',
    HC = 'HC'
}

/**
 * Encapsulates the errors that may be returned from the API.
 * @export
 * @interface Fault
 */
export interface Fault {
    /**
     * The set of specific errors associated with this fault, if any.
     * @type {Array<Error>}
     * @memberof Fault
     */
    errors?: Array<Error>;
    /**
     * The message of the fault.
     * @type {string}
     * @memberof Fault
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface HeartRateZoneRanges
 */
export interface HeartRateZoneRanges {
    /**
     * Whether the athlete has set their own custom heart rate zones
     * @type {boolean}
     * @memberof HeartRateZoneRanges
     */
    custom_zones?: boolean;
    /**
     * 
     * @type {Array<ZoneRange>}
     * @memberof HeartRateZoneRanges
     */
    zones?: Array<ZoneRange>;
}
/**
 * 
 * @export
 * @interface HeartrateStream
 */
export interface HeartrateStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof HeartrateStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof HeartrateStream
     */
    resolution?: HeartrateStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof HeartrateStream
     */
    series_type?: HeartrateStreamSeriesTypeEnum;
    /**
     * The sequence of heart rate values for this stream, in beats per minute
     * @type {Array<number>}
     * @memberof HeartrateStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum HeartrateStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum HeartrateStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface HeartrateStreamAllOf
 */
export interface HeartrateStreamAllOf {
    /**
     * The sequence of heart rate values for this stream, in beats per minute
     * @type {Array<number>}
     * @memberof HeartrateStreamAllOf
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface Lap
 */
export interface Lap {
    /**
     * The unique identifier of this lap
     * @type {number}
     * @memberof Lap
     */
    id?: number;
    /**
     * 
     * @type {MetaActivity}
     * @memberof Lap
     */
    activity?: MetaActivity;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof Lap
     */
    athlete?: MetaAthlete;
    /**
     * The lap\'s average cadence
     * @type {number}
     * @memberof Lap
     */
    average_cadence?: number;
    /**
     * The lap\'s average speed
     * @type {number}
     * @memberof Lap
     */
    average_speed?: number;
    /**
     * The lap\'s distance, in meters
     * @type {number}
     * @memberof Lap
     */
    distance?: number;
    /**
     * The lap\'s elapsed time, in seconds
     * @type {number}
     * @memberof Lap
     */
    elapsed_time?: number;
    /**
     * The start index of this effort in its activity\'s stream
     * @type {number}
     * @memberof Lap
     */
    start_index?: number;
    /**
     * The end index of this effort in its activity\'s stream
     * @type {number}
     * @memberof Lap
     */
    end_index?: number;
    /**
     * The index of this lap in the activity it belongs to
     * @type {number}
     * @memberof Lap
     */
    lap_index?: number;
    /**
     * The maximum speed of this lat, in meters per second
     * @type {number}
     * @memberof Lap
     */
    max_speed?: number;
    /**
     * The lap\'s moving time, in seconds
     * @type {number}
     * @memberof Lap
     */
    moving_time?: number;
    /**
     * The name of the lap
     * @type {string}
     * @memberof Lap
     */
    name?: string;
    /**
     * The athlete\'s pace zone during this lap
     * @type {number}
     * @memberof Lap
     */
    pace_zone?: number;
    /**
     * 
     * @type {number}
     * @memberof Lap
     */
    split?: number;
    /**
     * The time at which the lap was started.
     * @type {string}
     * @memberof Lap
     */
    start_date?: string;
    /**
     * The time at which the lap was started in the local timezone.
     * @type {string}
     * @memberof Lap
     */
    start_date_local?: string;
    /**
     * The elevation gain of this lap, in meters
     * @type {number}
     * @memberof Lap
     */
    total_elevation_gain?: number;
}
/**
 * 
 * @export
 * @interface LatLngStream
 */
export interface LatLngStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof LatLngStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof LatLngStream
     */
    resolution?: LatLngStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof LatLngStream
     */
    series_type?: LatLngStreamSeriesTypeEnum;
    /**
     * The sequence of lat/long values for this stream
     * @type {Array<Array<number>>}
     * @memberof LatLngStream
     */
    data?: Array<Array<number>>;
}

/**
    * @export
    * @enum {string}
    */
export enum LatLngStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum LatLngStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface LatLngStreamAllOf
 */
export interface LatLngStreamAllOf {
    /**
     * The sequence of lat/long values for this stream
     * @type {Array<Array<number>>}
     * @memberof LatLngStreamAllOf
     */
    data?: Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface MetaActivity
 */
export interface MetaActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof MetaActivity
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface MetaAthlete
 */
export interface MetaAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof MetaAthlete
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface MetaClub
 */
export interface MetaClub {
    /**
     * The club\'s unique identifier.
     * @type {number}
     * @memberof MetaClub
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof MetaClub
     */
    resource_state?: number;
    /**
     * The club\'s name.
     * @type {string}
     * @memberof MetaClub
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * The code associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    code?: string;
    /**
     * The specific field or aspect of the resource associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    field?: string;
    /**
     * The type of resource associated with this error.
     * @type {string}
     * @memberof ModelError
     */
    resource?: string;
}
/**
 * 
 * @export
 * @interface MovingStream
 */
export interface MovingStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof MovingStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof MovingStream
     */
    resolution?: MovingStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof MovingStream
     */
    series_type?: MovingStreamSeriesTypeEnum;
    /**
     * The sequence of moving values for this stream, as boolean values
     * @type {Array<boolean>}
     * @memberof MovingStream
     */
    data?: Array<boolean>;
}

/**
    * @export
    * @enum {string}
    */
export enum MovingStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum MovingStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface MovingStreamAllOf
 */
export interface MovingStreamAllOf {
    /**
     * The sequence of moving values for this stream, as boolean values
     * @type {Array<boolean>}
     * @memberof MovingStreamAllOf
     */
    data?: Array<boolean>;
}
/**
 * 
 * @export
 * @interface PhotosSummary
 */
export interface PhotosSummary {
    /**
     * The number of photos
     * @type {number}
     * @memberof PhotosSummary
     */
    count?: number;
    /**
     * 
     * @type {PhotosSummaryPrimary}
     * @memberof PhotosSummary
     */
    primary?: PhotosSummaryPrimary;
}
/**
 * 
 * @export
 * @interface PhotosSummaryPrimary
 */
export interface PhotosSummaryPrimary {
    /**
     * 
     * @type {number}
     * @memberof PhotosSummaryPrimary
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PhotosSummaryPrimary
     */
    source?: number;
    /**
     * 
     * @type {string}
     * @memberof PhotosSummaryPrimary
     */
    unique_id?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PhotosSummaryPrimary
     */
    urls?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PolylineMap
 */
export interface PolylineMap {
    /**
     * The identifier of the map
     * @type {string}
     * @memberof PolylineMap
     */
    id?: string;
    /**
     * The polyline of the map, only returned on detailed representation of an object
     * @type {string}
     * @memberof PolylineMap
     */
    polyline?: string;
    /**
     * The summary polyline of the map
     * @type {string}
     * @memberof PolylineMap
     */
    summary_polyline?: string;
}
/**
 * 
 * @export
 * @interface PowerStream
 */
export interface PowerStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof PowerStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof PowerStream
     */
    resolution?: PowerStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof PowerStream
     */
    series_type?: PowerStreamSeriesTypeEnum;
    /**
     * The sequence of power values for this stream, in watts
     * @type {Array<number>}
     * @memberof PowerStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum PowerStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum PowerStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface PowerStreamAllOf
 */
export interface PowerStreamAllOf {
    /**
     * The sequence of power values for this stream, in watts
     * @type {Array<number>}
     * @memberof PowerStreamAllOf
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface PowerZoneRanges
 */
export interface PowerZoneRanges {
    /**
     * 
     * @type {Array<ZoneRange>}
     * @memberof PowerZoneRanges
     */
    zones?: Array<ZoneRange>;
}
/**
 * 
 * @export
 * @interface Route
 */
export interface Route {
    /**
     * 
     * @type {SummaryAthlete}
     * @memberof Route
     */
    athlete?: SummaryAthlete;
    /**
     * The description of the route
     * @type {string}
     * @memberof Route
     */
    description?: string;
    /**
     * The route\'s distance, in meters
     * @type {number}
     * @memberof Route
     */
    distance?: number;
    /**
     * The route\'s elevation gain.
     * @type {number}
     * @memberof Route
     */
    elevation_gain?: number;
    /**
     * The unique identifier of this route
     * @type {number}
     * @memberof Route
     */
    id?: number;
    /**
     * The unique identifier of the route in string format
     * @type {string}
     * @memberof Route
     */
    id_str?: string;
    /**
     * 
     * @type {PolylineMap}
     * @memberof Route
     */
    map?: PolylineMap;
    /**
     * The name of this route
     * @type {string}
     * @memberof Route
     */
    name?: string;
    /**
     * Whether this route is private
     * @type {boolean}
     * @memberof Route
     */
    _private?: boolean;
    /**
     * Whether this route is starred by the logged-in athlete
     * @type {boolean}
     * @memberof Route
     */
    starred?: boolean;
    /**
     * An epoch timestamp of when the route was created
     * @type {number}
     * @memberof Route
     */
    timestamp?: number;
    /**
     * This route\'s type (1 for ride, 2 for runs)
     * @type {number}
     * @memberof Route
     */
    type?: number;
    /**
     * This route\'s sub-type (1 for road, 2 for mountain bike, 3 for cross, 4 for trail, 5 for mixed)
     * @type {number}
     * @memberof Route
     */
    sub_type?: number;
    /**
     * The segments traversed by this route
     * @type {Array<SummarySegment>}
     * @memberof Route
     */
    segments?: Array<SummarySegment>;
}
/**
 * 
 * @export
 * @interface RunningRace
 */
export interface RunningRace {
    /**
     * The unique identifier of this race.
     * @type {number}
     * @memberof RunningRace
     */
    id?: number;
    /**
     * The name of this race.
     * @type {string}
     * @memberof RunningRace
     */
    name?: string;
    /**
     * The type of this race.
     * @type {number}
     * @memberof RunningRace
     */
    running_race_type?: number;
    /**
     * The race\'s distance, in meters.
     * @type {number}
     * @memberof RunningRace
     */
    distance?: number;
    /**
     * The time at which the race begins started in the local timezone.
     * @type {string}
     * @memberof RunningRace
     */
    start_date_local?: string;
    /**
     * The name of the city in which the race is taking place.
     * @type {string}
     * @memberof RunningRace
     */
    city?: string;
    /**
     * The name of the state or geographical region in which the race is taking place.
     * @type {string}
     * @memberof RunningRace
     */
    state?: string;
    /**
     * The name of the country in which the race is taking place.
     * @type {string}
     * @memberof RunningRace
     */
    country?: string;
    /**
     * The set of routes that cover this race\'s course.
     * @type {Array<number>}
     * @memberof RunningRace
     */
    route_ids?: Array<number>;
    /**
     * The unit system in which the race should be displayed.
     * @type {string}
     * @memberof RunningRace
     */
    measurement_preference?: RunningRaceMeasurementPreferenceEnum;
    /**
     * The vanity URL of this race on Strava.
     * @type {string}
     * @memberof RunningRace
     */
    url?: string;
    /**
     * The URL of this race\'s website.
     * @type {string}
     * @memberof RunningRace
     */
    website_url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RunningRaceMeasurementPreferenceEnum {
    Feet = 'feet',
    Meters = 'meters'
}

/**
 * 
 * @export
 * @interface SmoothGradeStream
 */
export interface SmoothGradeStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof SmoothGradeStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof SmoothGradeStream
     */
    resolution?: SmoothGradeStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof SmoothGradeStream
     */
    series_type?: SmoothGradeStreamSeriesTypeEnum;
    /**
     * The sequence of grade values for this stream, as percents of a grade
     * @type {Array<number>}
     * @memberof SmoothGradeStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum SmoothGradeStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum SmoothGradeStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface SmoothGradeStreamAllOf
 */
export interface SmoothGradeStreamAllOf {
    /**
     * The sequence of grade values for this stream, as percents of a grade
     * @type {Array<number>}
     * @memberof SmoothGradeStreamAllOf
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface SmoothVelocityStream
 */
export interface SmoothVelocityStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof SmoothVelocityStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof SmoothVelocityStream
     */
    resolution?: SmoothVelocityStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof SmoothVelocityStream
     */
    series_type?: SmoothVelocityStreamSeriesTypeEnum;
    /**
     * The sequence of velocity values for this stream, in meters per second
     * @type {Array<number>}
     * @memberof SmoothVelocityStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum SmoothVelocityStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum SmoothVelocityStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface SmoothVelocityStreamAllOf
 */
export interface SmoothVelocityStreamAllOf {
    /**
     * The sequence of velocity values for this stream, in meters per second
     * @type {Array<number>}
     * @memberof SmoothVelocityStreamAllOf
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface Split
 */
export interface Split {
    /**
     * The average speed of this split, in meters per second
     * @type {number}
     * @memberof Split
     */
    average_speed?: number;
    /**
     * The distance of this split, in meters
     * @type {number}
     * @memberof Split
     */
    distance?: number;
    /**
     * The elapsed time of this split, in seconds
     * @type {number}
     * @memberof Split
     */
    elapsed_time?: number;
    /**
     * The elevation difference of this split, in meters
     * @type {number}
     * @memberof Split
     */
    elevation_difference?: number;
    /**
     * The pacing zone of this split
     * @type {number}
     * @memberof Split
     */
    pace_zone?: number;
    /**
     * The moving time of this split, in seconds
     * @type {number}
     * @memberof Split
     */
    moving_time?: number;
    /**
     * N/A
     * @type {number}
     * @memberof Split
     */
    split?: number;
}
/**
 * 
 * @export
 * @interface StreamSet
 */
export interface StreamSet {
    /**
     * 
     * @type {TimeStream}
     * @memberof StreamSet
     */
    time?: TimeStream;
    /**
     * 
     * @type {DistanceStream}
     * @memberof StreamSet
     */
    distance?: DistanceStream;
    /**
     * 
     * @type {LatLngStream}
     * @memberof StreamSet
     */
    latlng?: LatLngStream;
    /**
     * 
     * @type {AltitudeStream}
     * @memberof StreamSet
     */
    altitude?: AltitudeStream;
    /**
     * 
     * @type {SmoothVelocityStream}
     * @memberof StreamSet
     */
    velocity_smooth?: SmoothVelocityStream;
    /**
     * 
     * @type {HeartrateStream}
     * @memberof StreamSet
     */
    heartrate?: HeartrateStream;
    /**
     * 
     * @type {CadenceStream}
     * @memberof StreamSet
     */
    cadence?: CadenceStream;
    /**
     * 
     * @type {PowerStream}
     * @memberof StreamSet
     */
    watts?: PowerStream;
    /**
     * 
     * @type {TemperatureStream}
     * @memberof StreamSet
     */
    temp?: TemperatureStream;
    /**
     * 
     * @type {MovingStream}
     * @memberof StreamSet
     */
    moving?: MovingStream;
    /**
     * 
     * @type {SmoothGradeStream}
     * @memberof StreamSet
     */
    grade_smooth?: SmoothGradeStream;
}
/**
 * 
 * @export
 * @interface SummaryActivity
 */
export interface SummaryActivity {
    /**
     * The unique identifier of the activity
     * @type {number}
     * @memberof SummaryActivity
     */
    id?: number;
    /**
     * The identifier provided at upload time
     * @type {string}
     * @memberof SummaryActivity
     */
    external_id?: string;
    /**
     * The identifier of the upload that resulted in this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    upload_id?: number;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof SummaryActivity
     */
    athlete?: MetaAthlete;
    /**
     * The name of the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    name?: string;
    /**
     * The activity\'s distance, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    distance?: number;
    /**
     * The activity\'s moving time, in seconds
     * @type {number}
     * @memberof SummaryActivity
     */
    moving_time?: number;
    /**
     * The activity\'s elapsed time, in seconds
     * @type {number}
     * @memberof SummaryActivity
     */
    elapsed_time?: number;
    /**
     * The activity\'s total elevation gain.
     * @type {number}
     * @memberof SummaryActivity
     */
    total_elevation_gain?: number;
    /**
     * The activity\'s highest elevation, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    elev_high?: number;
    /**
     * The activity\'s lowest elevation, in meters
     * @type {number}
     * @memberof SummaryActivity
     */
    elev_low?: number;
    /**
     * 
     * @type {ActivityType}
     * @memberof SummaryActivity
     */
    type?: ActivityType;
    /**
     * The time at which the activity was started.
     * @type {string}
     * @memberof SummaryActivity
     */
    start_date?: string;
    /**
     * The time at which the activity was started in the local timezone.
     * @type {string}
     * @memberof SummaryActivity
     */
    start_date_local?: string;
    /**
     * The timezone of the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    timezone?: string;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummaryActivity
     */
    start_latlng?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummaryActivity
     */
    end_latlng?: Array<number>;
    /**
     * The number of achievements gained during this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    achievement_count?: number;
    /**
     * The number of kudos given for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    kudos_count?: number;
    /**
     * The number of comments for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    comment_count?: number;
    /**
     * The number of athletes for taking part in a group activity
     * @type {number}
     * @memberof SummaryActivity
     */
    athlete_count?: number;
    /**
     * The number of Instagram photos for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    photo_count?: number;
    /**
     * The number of Instagram and Strava photos for this activity
     * @type {number}
     * @memberof SummaryActivity
     */
    total_photo_count?: number;
    /**
     * 
     * @type {PolylineMap}
     * @memberof SummaryActivity
     */
    map?: PolylineMap;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof SummaryActivity
     */
    trainer?: boolean;
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof SummaryActivity
     */
    commute?: boolean;
    /**
     * Whether this activity was created manually
     * @type {boolean}
     * @memberof SummaryActivity
     */
    manual?: boolean;
    /**
     * Whether this activity is private
     * @type {boolean}
     * @memberof SummaryActivity
     */
    _private?: boolean;
    /**
     * Whether this activity is flagged
     * @type {boolean}
     * @memberof SummaryActivity
     */
    flagged?: boolean;
    /**
     * The activity\'s workout type
     * @type {number}
     * @memberof SummaryActivity
     */
    workout_type?: number;
    /**
     * The unique identifier of the upload in string format
     * @type {string}
     * @memberof SummaryActivity
     */
    upload_id_str?: string;
    /**
     * The activity\'s average speed, in meters per second
     * @type {number}
     * @memberof SummaryActivity
     */
    average_speed?: number;
    /**
     * The activity\'s max speed, in meters per second
     * @type {number}
     * @memberof SummaryActivity
     */
    max_speed?: number;
    /**
     * Whether the logged-in athlete has kudoed this activity
     * @type {boolean}
     * @memberof SummaryActivity
     */
    has_kudoed?: boolean;
    /**
     * The id of the gear for the activity
     * @type {string}
     * @memberof SummaryActivity
     */
    gear_id?: string;
    /**
     * The total work done in kilojoules during this activity. Rides only
     * @type {number}
     * @memberof SummaryActivity
     */
    kilojoules?: number;
    /**
     * Average power output in watts during this activity. Rides only
     * @type {number}
     * @memberof SummaryActivity
     */
    average_watts?: number;
    /**
     * Whether the watts are from a power meter, false if estimated
     * @type {boolean}
     * @memberof SummaryActivity
     */
    device_watts?: boolean;
    /**
     * Rides with power meter data only
     * @type {number}
     * @memberof SummaryActivity
     */
    max_watts?: number;
    /**
     * Similar to Normalized Power. Rides with power meter data only
     * @type {number}
     * @memberof SummaryActivity
     */
    weighted_average_watts?: number;
}
/**
 * 
 * @export
 * @interface SummaryActivityAllOf
 */
export interface SummaryActivityAllOf {
    /**
     * The identifier provided at upload time
     * @type {string}
     * @memberof SummaryActivityAllOf
     */
    external_id?: string;
    /**
     * The identifier of the upload that resulted in this activity
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    upload_id?: number;
    /**
     * 
     * @type {MetaAthlete}
     * @memberof SummaryActivityAllOf
     */
    athlete?: MetaAthlete;
    /**
     * The name of the activity
     * @type {string}
     * @memberof SummaryActivityAllOf
     */
    name?: string;
    /**
     * The activity\'s distance, in meters
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    distance?: number;
    /**
     * The activity\'s moving time, in seconds
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    moving_time?: number;
    /**
     * The activity\'s elapsed time, in seconds
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    elapsed_time?: number;
    /**
     * The activity\'s total elevation gain.
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    total_elevation_gain?: number;
    /**
     * The activity\'s highest elevation, in meters
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    elev_high?: number;
    /**
     * The activity\'s lowest elevation, in meters
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    elev_low?: number;
    /**
     * 
     * @type {ActivityType}
     * @memberof SummaryActivityAllOf
     */
    type?: ActivityType;
    /**
     * The time at which the activity was started.
     * @type {string}
     * @memberof SummaryActivityAllOf
     */
    start_date?: string;
    /**
     * The time at which the activity was started in the local timezone.
     * @type {string}
     * @memberof SummaryActivityAllOf
     */
    start_date_local?: string;
    /**
     * The timezone of the activity
     * @type {string}
     * @memberof SummaryActivityAllOf
     */
    timezone?: string;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummaryActivityAllOf
     */
    start_latlng?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummaryActivityAllOf
     */
    end_latlng?: Array<number>;
    /**
     * The number of achievements gained during this activity
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    achievement_count?: number;
    /**
     * The number of kudos given for this activity
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    kudos_count?: number;
    /**
     * The number of comments for this activity
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    comment_count?: number;
    /**
     * The number of athletes for taking part in a group activity
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    athlete_count?: number;
    /**
     * The number of Instagram photos for this activity
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    photo_count?: number;
    /**
     * The number of Instagram and Strava photos for this activity
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    total_photo_count?: number;
    /**
     * 
     * @type {PolylineMap}
     * @memberof SummaryActivityAllOf
     */
    map?: PolylineMap;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof SummaryActivityAllOf
     */
    trainer?: boolean;
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof SummaryActivityAllOf
     */
    commute?: boolean;
    /**
     * Whether this activity was created manually
     * @type {boolean}
     * @memberof SummaryActivityAllOf
     */
    manual?: boolean;
    /**
     * Whether this activity is private
     * @type {boolean}
     * @memberof SummaryActivityAllOf
     */
    _private?: boolean;
    /**
     * Whether this activity is flagged
     * @type {boolean}
     * @memberof SummaryActivityAllOf
     */
    flagged?: boolean;
    /**
     * The activity\'s workout type
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    workout_type?: number;
    /**
     * The unique identifier of the upload in string format
     * @type {string}
     * @memberof SummaryActivityAllOf
     */
    upload_id_str?: string;
    /**
     * The activity\'s average speed, in meters per second
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    average_speed?: number;
    /**
     * The activity\'s max speed, in meters per second
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    max_speed?: number;
    /**
     * Whether the logged-in athlete has kudoed this activity
     * @type {boolean}
     * @memberof SummaryActivityAllOf
     */
    has_kudoed?: boolean;
    /**
     * The id of the gear for the activity
     * @type {string}
     * @memberof SummaryActivityAllOf
     */
    gear_id?: string;
    /**
     * The total work done in kilojoules during this activity. Rides only
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    kilojoules?: number;
    /**
     * Average power output in watts during this activity. Rides only
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    average_watts?: number;
    /**
     * Whether the watts are from a power meter, false if estimated
     * @type {boolean}
     * @memberof SummaryActivityAllOf
     */
    device_watts?: boolean;
    /**
     * Rides with power meter data only
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    max_watts?: number;
    /**
     * Similar to Normalized Power. Rides with power meter data only
     * @type {number}
     * @memberof SummaryActivityAllOf
     */
    weighted_average_watts?: number;
}
/**
 * 
 * @export
 * @interface SummaryAthlete
 */
export interface SummaryAthlete {
    /**
     * The unique identifier of the athlete
     * @type {number}
     * @memberof SummaryAthlete
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryAthlete
     */
    resource_state?: number;
    /**
     * The athlete\'s first name.
     * @type {string}
     * @memberof SummaryAthlete
     */
    firstname?: string;
    /**
     * The athlete\'s last name.
     * @type {string}
     * @memberof SummaryAthlete
     */
    lastname?: string;
    /**
     * URL to a 62x62 pixel profile picture.
     * @type {string}
     * @memberof SummaryAthlete
     */
    profile_medium?: string;
    /**
     * URL to a 124x124 pixel profile picture.
     * @type {string}
     * @memberof SummaryAthlete
     */
    profile?: string;
    /**
     * The athlete\'s city.
     * @type {string}
     * @memberof SummaryAthlete
     */
    city?: string;
    /**
     * The athlete\'s state or geographical region.
     * @type {string}
     * @memberof SummaryAthlete
     */
    state?: string;
    /**
     * The athlete\'s country.
     * @type {string}
     * @memberof SummaryAthlete
     */
    country?: string;
    /**
     * The athlete\'s sex.
     * @type {string}
     * @memberof SummaryAthlete
     */
    sex?: SummaryAthleteSexEnum;
    /**
     * Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof SummaryAthlete
     */
    premium?: boolean;
    /**
     * Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof SummaryAthlete
     */
    summit?: boolean;
    /**
     * The time at which the athlete was created.
     * @type {string}
     * @memberof SummaryAthlete
     */
    created_at?: string;
    /**
     * The time at which the athlete was last updated.
     * @type {string}
     * @memberof SummaryAthlete
     */
    updated_at?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SummaryAthleteSexEnum {
    M = 'M',
    F = 'F'
}

/**
 * 
 * @export
 * @interface SummaryAthleteAllOf
 */
export interface SummaryAthleteAllOf {
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryAthleteAllOf
     */
    resource_state?: number;
    /**
     * The athlete\'s first name.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    firstname?: string;
    /**
     * The athlete\'s last name.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    lastname?: string;
    /**
     * URL to a 62x62 pixel profile picture.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    profile_medium?: string;
    /**
     * URL to a 124x124 pixel profile picture.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    profile?: string;
    /**
     * The athlete\'s city.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    city?: string;
    /**
     * The athlete\'s state or geographical region.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    state?: string;
    /**
     * The athlete\'s country.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    country?: string;
    /**
     * The athlete\'s sex.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    sex?: SummaryAthleteAllOfSexEnum;
    /**
     * Deprecated.  Use summit field instead. Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof SummaryAthleteAllOf
     */
    premium?: boolean;
    /**
     * Whether the athlete has any Summit subscription.
     * @type {boolean}
     * @memberof SummaryAthleteAllOf
     */
    summit?: boolean;
    /**
     * The time at which the athlete was created.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    created_at?: string;
    /**
     * The time at which the athlete was last updated.
     * @type {string}
     * @memberof SummaryAthleteAllOf
     */
    updated_at?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SummaryAthleteAllOfSexEnum {
    M = 'M',
    F = 'F'
}

/**
 * 
 * @export
 * @interface SummaryClub
 */
export interface SummaryClub {
    /**
     * The club\'s unique identifier.
     * @type {number}
     * @memberof SummaryClub
     */
    id?: number;
    /**
     * Resource state, indicates level of detail. Possible values: 1 -> \"meta\", 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryClub
     */
    resource_state?: number;
    /**
     * The club\'s name.
     * @type {string}
     * @memberof SummaryClub
     */
    name?: string;
    /**
     * URL to a 60x60 pixel profile picture.
     * @type {string}
     * @memberof SummaryClub
     */
    profile_medium?: string;
    /**
     * URL to a ~1185x580 pixel cover photo.
     * @type {string}
     * @memberof SummaryClub
     */
    cover_photo?: string;
    /**
     * URL to a ~360x176  pixel cover photo.
     * @type {string}
     * @memberof SummaryClub
     */
    cover_photo_small?: string;
    /**
     * 
     * @type {string}
     * @memberof SummaryClub
     */
    sport_type?: SummaryClubSportTypeEnum;
    /**
     * The club\'s city.
     * @type {string}
     * @memberof SummaryClub
     */
    city?: string;
    /**
     * The club\'s state or geographical region.
     * @type {string}
     * @memberof SummaryClub
     */
    state?: string;
    /**
     * The club\'s country.
     * @type {string}
     * @memberof SummaryClub
     */
    country?: string;
    /**
     * Whether the club is private.
     * @type {boolean}
     * @memberof SummaryClub
     */
    _private?: boolean;
    /**
     * The club\'s member count.
     * @type {number}
     * @memberof SummaryClub
     */
    member_count?: number;
    /**
     * Whether the club is featured or not.
     * @type {boolean}
     * @memberof SummaryClub
     */
    featured?: boolean;
    /**
     * Whether the club is verified or not.
     * @type {boolean}
     * @memberof SummaryClub
     */
    verified?: boolean;
    /**
     * The club\'s vanity URL.
     * @type {string}
     * @memberof SummaryClub
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SummaryClubSportTypeEnum {
    Cycling = 'cycling',
    Running = 'running',
    Triathlon = 'triathlon',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface SummaryClubAllOf
 */
export interface SummaryClubAllOf {
    /**
     * URL to a 60x60 pixel profile picture.
     * @type {string}
     * @memberof SummaryClubAllOf
     */
    profile_medium?: string;
    /**
     * URL to a ~1185x580 pixel cover photo.
     * @type {string}
     * @memberof SummaryClubAllOf
     */
    cover_photo?: string;
    /**
     * URL to a ~360x176  pixel cover photo.
     * @type {string}
     * @memberof SummaryClubAllOf
     */
    cover_photo_small?: string;
    /**
     * 
     * @type {string}
     * @memberof SummaryClubAllOf
     */
    sport_type?: SummaryClubAllOfSportTypeEnum;
    /**
     * The club\'s city.
     * @type {string}
     * @memberof SummaryClubAllOf
     */
    city?: string;
    /**
     * The club\'s state or geographical region.
     * @type {string}
     * @memberof SummaryClubAllOf
     */
    state?: string;
    /**
     * The club\'s country.
     * @type {string}
     * @memberof SummaryClubAllOf
     */
    country?: string;
    /**
     * Whether the club is private.
     * @type {boolean}
     * @memberof SummaryClubAllOf
     */
    _private?: boolean;
    /**
     * The club\'s member count.
     * @type {number}
     * @memberof SummaryClubAllOf
     */
    member_count?: number;
    /**
     * Whether the club is featured or not.
     * @type {boolean}
     * @memberof SummaryClubAllOf
     */
    featured?: boolean;
    /**
     * Whether the club is verified or not.
     * @type {boolean}
     * @memberof SummaryClubAllOf
     */
    verified?: boolean;
    /**
     * The club\'s vanity URL.
     * @type {string}
     * @memberof SummaryClubAllOf
     */
    url?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SummaryClubAllOfSportTypeEnum {
    Cycling = 'cycling',
    Running = 'running',
    Triathlon = 'triathlon',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface SummaryGear
 */
export interface SummaryGear {
    /**
     * The gear\'s unique identifier.
     * @type {string}
     * @memberof SummaryGear
     */
    id?: string;
    /**
     * Resource state, indicates level of detail. Possible values: 2 -> \"summary\", 3 -> \"detail\"
     * @type {number}
     * @memberof SummaryGear
     */
    resource_state?: number;
    /**
     * Whether this gear\'s is the owner\'s default one.
     * @type {boolean}
     * @memberof SummaryGear
     */
    primary?: boolean;
    /**
     * The gear\'s name.
     * @type {string}
     * @memberof SummaryGear
     */
    name?: string;
    /**
     * The distance logged with this gear.
     * @type {number}
     * @memberof SummaryGear
     */
    distance?: number;
}
/**
 * 
 * @export
 * @interface SummarySegment
 */
export interface SummarySegment {
    /**
     * The unique identifier of this segment
     * @type {number}
     * @memberof SummarySegment
     */
    id?: number;
    /**
     * The name of this segment
     * @type {string}
     * @memberof SummarySegment
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof SummarySegment
     */
    activity_type?: SummarySegmentActivityTypeEnum;
    /**
     * The segment\'s distance, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    distance?: number;
    /**
     * The segment\'s average grade, in percents
     * @type {number}
     * @memberof SummarySegment
     */
    average_grade?: number;
    /**
     * The segments\'s maximum grade, in percents
     * @type {number}
     * @memberof SummarySegment
     */
    maximum_grade?: number;
    /**
     * The segments\'s highest elevation, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    elevation_high?: number;
    /**
     * The segments\'s lowest elevation, in meters
     * @type {number}
     * @memberof SummarySegment
     */
    elevation_low?: number;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummarySegment
     */
    start_latlng?: Array<number>;
    /**
     * A pair of latitude/longitude coordinates, represented as an array of 2 floating point numbers.
     * @type {Array<number>}
     * @memberof SummarySegment
     */
    end_latlng?: Array<number>;
    /**
     * The category of the climb [0, 5]. Higher is harder ie. 5 is Hors catégorie, 0 is uncategorized in climb_category.
     * @type {number}
     * @memberof SummarySegment
     */
    climb_category?: number;
    /**
     * The segments\'s city.
     * @type {string}
     * @memberof SummarySegment
     */
    city?: string;
    /**
     * The segments\'s state or geographical region.
     * @type {string}
     * @memberof SummarySegment
     */
    state?: string;
    /**
     * The segment\'s country.
     * @type {string}
     * @memberof SummarySegment
     */
    country?: string;
    /**
     * Whether this segment is private.
     * @type {boolean}
     * @memberof SummarySegment
     */
    _private?: boolean;
    /**
     * 
     * @type {SummarySegmentEffort}
     * @memberof SummarySegment
     */
    athlete_pr_effort?: SummarySegmentEffort;
}

/**
    * @export
    * @enum {string}
    */
export enum SummarySegmentActivityTypeEnum {
    Ride = 'Ride',
    Run = 'Run'
}

/**
 * 
 * @export
 * @interface SummarySegmentEffort
 */
export interface SummarySegmentEffort {
    /**
     * The unique identifier of this effort
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    id?: number;
    /**
     * The effort\'s elapsed time
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    elapsed_time?: number;
    /**
     * The time at which the effort was started.
     * @type {string}
     * @memberof SummarySegmentEffort
     */
    start_date?: string;
    /**
     * The time at which the effort was started in the local timezone.
     * @type {string}
     * @memberof SummarySegmentEffort
     */
    start_date_local?: string;
    /**
     * The effort\'s distance in meters
     * @type {number}
     * @memberof SummarySegmentEffort
     */
    distance?: number;
    /**
     * Whether this effort is the current best on the leaderboard
     * @type {boolean}
     * @memberof SummarySegmentEffort
     */
    is_kom?: boolean;
}
/**
 * 
 * @export
 * @interface TemperatureStream
 */
export interface TemperatureStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof TemperatureStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof TemperatureStream
     */
    resolution?: TemperatureStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof TemperatureStream
     */
    series_type?: TemperatureStreamSeriesTypeEnum;
    /**
     * The sequence of temperature values for this stream, in celsius degrees
     * @type {Array<number>}
     * @memberof TemperatureStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum TemperatureStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum TemperatureStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface TemperatureStreamAllOf
 */
export interface TemperatureStreamAllOf {
    /**
     * The sequence of temperature values for this stream, in celsius degrees
     * @type {Array<number>}
     * @memberof TemperatureStreamAllOf
     */
    data?: Array<number>;
}
/**
 * 
 * @export
 * @interface TimeStream
 */
export interface TimeStream {
    /**
     * The number of data points in this stream
     * @type {number}
     * @memberof TimeStream
     */
    original_size?: number;
    /**
     * The level of detail (sampling) in which this stream was returned
     * @type {string}
     * @memberof TimeStream
     */
    resolution?: TimeStreamResolutionEnum;
    /**
     * The base series used in the case the stream was downsampled
     * @type {string}
     * @memberof TimeStream
     */
    series_type?: TimeStreamSeriesTypeEnum;
    /**
     * The sequence of time values for this stream, in seconds
     * @type {Array<number>}
     * @memberof TimeStream
     */
    data?: Array<number>;
}

/**
    * @export
    * @enum {string}
    */
export enum TimeStreamResolutionEnum {
    Low = 'low',
    Medium = 'medium',
    High = 'high'
}
/**
    * @export
    * @enum {string}
    */
export enum TimeStreamSeriesTypeEnum {
    Distance = 'distance',
    Time = 'time'
}

/**
 * 
 * @export
 * @interface TimeStreamAllOf
 */
export interface TimeStreamAllOf {
    /**
     * The sequence of time values for this stream, in seconds
     * @type {Array<number>}
     * @memberof TimeStreamAllOf
     */
    data?: Array<number>;
}
/**
 * A union type representing the time spent in a given zone.
 * @export
 * @interface TimedZoneRange
 */
export interface TimedZoneRange {
    /**
     * The minimum value in the range.
     * @type {number}
     * @memberof TimedZoneRange
     */
    min?: number;
    /**
     * The maximum value in the range.
     * @type {number}
     * @memberof TimedZoneRange
     */
    max?: number;
    /**
     * The number of seconds spent in this zone
     * @type {number}
     * @memberof TimedZoneRange
     */
    time?: number;
}
/**
 * 
 * @export
 * @interface TimedZoneRangeAllOf
 */
export interface TimedZoneRangeAllOf {
    /**
     * The number of seconds spent in this zone
     * @type {number}
     * @memberof TimedZoneRangeAllOf
     */
    time?: number;
}
/**
 * 
 * @export
 * @interface UpdatableActivity
 */
export interface UpdatableActivity {
    /**
     * Whether this activity is a commute
     * @type {boolean}
     * @memberof UpdatableActivity
     */
    commute?: boolean;
    /**
     * Whether this activity was recorded on a training machine
     * @type {boolean}
     * @memberof UpdatableActivity
     */
    trainer?: boolean;
    /**
     * The description of the activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    description?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    name?: string;
    /**
     * 
     * @type {ActivityType}
     * @memberof UpdatableActivity
     */
    type?: ActivityType;
    /**
     * Identifier for the gear associated with the activity. ‘none’ clears gear from activity
     * @type {string}
     * @memberof UpdatableActivity
     */
    gear_id?: string;
}
/**
 * 
 * @export
 * @interface Upload
 */
export interface Upload {
    /**
     * The unique identifier of the upload
     * @type {number}
     * @memberof Upload
     */
    id?: number;
    /**
     * The unique identifier of the upload in string format
     * @type {string}
     * @memberof Upload
     */
    id_str?: string;
    /**
     * The external identifier of the upload
     * @type {string}
     * @memberof Upload
     */
    external_id?: string;
    /**
     * The error associated with this upload
     * @type {string}
     * @memberof Upload
     */
    error?: string;
    /**
     * The status of this upload
     * @type {string}
     * @memberof Upload
     */
    status?: string;
    /**
     * The identifier of the activity this upload resulted into
     * @type {number}
     * @memberof Upload
     */
    activity_id?: number;
}
/**
 * 
 * @export
 * @interface ZoneRange
 */
export interface ZoneRange {
    /**
     * The minimum value in the range.
     * @type {number}
     * @memberof ZoneRange
     */
    min?: number;
    /**
     * The maximum value in the range.
     * @type {number}
     * @memberof ZoneRange
     */
    max?: number;
}
/**
 * 
 * @export
 * @interface Zones
 */
export interface Zones {
    /**
     * 
     * @type {HeartRateZoneRanges}
     * @memberof Zones
     */
    heart_rate?: HeartRateZoneRanges;
    /**
     * 
     * @type {PowerZoneRanges}
     * @memberof Zones
     */
    power?: PowerZoneRanges;
}

/**
 * ActivitiesApi - axios parameter creator
 * @export
 */
export const ActivitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a manual activity for an athlete, requires activity:write scope.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} type Type of activity. For example - Run, Ride etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [description] Description of the activity.
         * @param {number} [distance] In meters.
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity: async (name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: number, trainer?: number, commute?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createActivity.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling createActivity.');
            }
            // verify required parameter 'startDateLocal' is not null or undefined
            if (startDateLocal === null || startDateLocal === undefined) {
                throw new RequiredError('startDateLocal','Required parameter startDateLocal was null or undefined when calling createActivity.');
            }
            // verify required parameter 'elapsedTime' is not null or undefined
            if (elapsedTime === null || elapsedTime === undefined) {
                throw new RequiredError('elapsedTime','Required parameter elapsedTime was null or undefined when calling createActivity.');
            }
            const localVarPath = `/activities`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.append('type', type as any);
            }
    
            if (startDateLocal !== undefined) { 
                localVarFormParams.append('start_date_local', startDateLocal as any);
            }
    
            if (elapsedTime !== undefined) { 
                localVarFormParams.append('elapsed_time', elapsedTime as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (distance !== undefined) { 
                localVarFormParams.append('distance', distance as any);
            }
    
            if (trainer !== undefined) { 
                localVarFormParams.append('trainer', trainer as any);
            }
    
            if (commute !== undefined) { 
                localVarFormParams.append('commute', commute as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityById: async (id: number, includeAllEfforts?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivityById.');
            }
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (includeAllEfforts !== undefined) {
                localVarQueryParameter['include_all_efforts'] = includeAllEfforts;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByActivityId: async (id: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCommentsByActivityId.');
            }
            const localVarPath = `/activities/{id}/comments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Kudoers
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKudoersByActivityId: async (id: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getKudoersByActivityId.');
            }
            const localVarPath = `/activities/{id}/kudos`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Laps
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLapsByActivityId: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getLapsByActivityId.');
            }
            const localVarPath = `/activities/{id}/laps`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteActivities: async (before?: number, after?: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/athlete/activities`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = before;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity Zones
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZonesByActivityId: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getZonesByActivityId.');
            }
            const localVarPath = `/activities/{id}/zones`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityById: async (id: number, body?: UpdatableActivity, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateActivityById.');
            }
            const localVarPath = `/activities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ActivitiesApi - functional programming interface
 * @export
 */
export const ActivitiesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a manual activity for an athlete, requires activity:write scope.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} type Type of activity. For example - Run, Ride etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [description] Description of the activity.
         * @param {number} [distance] In meters.
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createActivity(name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: number, trainer?: number, commute?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedActivity>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).createActivity(name, type, startDateLocal, elapsedTime, description, distance, trainer, commute, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityById(id: number, includeAllEfforts?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedActivity>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).getActivityById(id, includeAllEfforts, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCommentsByActivityId(id: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Comment>>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).getCommentsByActivityId(id, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Kudoers
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKudoersByActivityId(id: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummaryAthlete>>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).getKudoersByActivityId(id, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Laps
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLapsByActivityId(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Lap>>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).getLapsByActivityId(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummaryActivity>>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).getLoggedInAthleteActivities(before, after, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity Zones
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZonesByActivityId(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ActivityZone>>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).getZonesByActivityId(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateActivityById(id: number, body?: UpdatableActivity, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedActivity>> {
            const localVarAxiosArgs = await ActivitiesApiAxiosParamCreator(configuration).updateActivityById(id, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ActivitiesApi - factory interface
 * @export
 */
export const ActivitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Creates a manual activity for an athlete, requires activity:write scope.
         * @summary Create an Activity
         * @param {string} name The name of the activity.
         * @param {string} type Type of activity. For example - Run, Ride etc.
         * @param {string} startDateLocal ISO 8601 formatted date time.
         * @param {number} elapsedTime In seconds.
         * @param {string} [description] Description of the activity.
         * @param {number} [distance] In meters.
         * @param {number} [trainer] Set to 1 to mark as a trainer activity.
         * @param {number} [commute] Set to 1 to mark as commute.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createActivity(name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: number, trainer?: number, commute?: number, options?: any): AxiosPromise<DetailedActivity> {
            return ActivitiesApiFp(configuration).createActivity(name, type, startDateLocal, elapsedTime, description, distance, trainer, commute, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity
         * @param {number} id The identifier of the activity.
         * @param {boolean} [includeAllEfforts] To include all segments efforts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityById(id: number, includeAllEfforts?: boolean, options?: any): AxiosPromise<DetailedActivity> {
            return ActivitiesApiFp(configuration).getActivityById(id, includeAllEfforts, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Comments
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommentsByActivityId(id: number, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Comment>> {
            return ActivitiesApiFp(configuration).getCommentsByActivityId(id, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Kudoers
         * @param {number} id The identifier of the activity.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKudoersByActivityId(id: number, page?: number, perPage?: number, options?: any): AxiosPromise<Array<SummaryAthlete>> {
            return ActivitiesApiFp(configuration).getKudoersByActivityId(id, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary List Activity Laps
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLapsByActivityId(id: number, options?: any): AxiosPromise<Array<Lap>> {
            return ActivitiesApiFp(configuration).getLapsByActivityId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
         * @summary List Athlete Activities
         * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
         * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: any): AxiosPromise<Array<SummaryActivity>> {
            return ActivitiesApiFp(configuration).getLoggedInAthleteActivities(before, after, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
         * @summary Get Activity Zones
         * @param {number} id The identifier of the activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZonesByActivityId(id: number, options?: any): AxiosPromise<Array<ActivityZone>> {
            return ActivitiesApiFp(configuration).getZonesByActivityId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
         * @summary Update Activity
         * @param {number} id The identifier of the activity.
         * @param {UpdatableActivity} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateActivityById(id: number, body?: UpdatableActivity, options?: any): AxiosPromise<DetailedActivity> {
            return ActivitiesApiFp(configuration).updateActivityById(id, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActivitiesApi - object-oriented interface
 * @export
 * @class ActivitiesApi
 * @extends {BaseAPI}
 */
export class ActivitiesApi extends BaseAPI {
    /**
     * Creates a manual activity for an athlete, requires activity:write scope.
     * @summary Create an Activity
     * @param {string} name The name of the activity.
     * @param {string} type Type of activity. For example - Run, Ride etc.
     * @param {string} startDateLocal ISO 8601 formatted date time.
     * @param {number} elapsedTime In seconds.
     * @param {string} [description] Description of the activity.
     * @param {number} [distance] In meters.
     * @param {number} [trainer] Set to 1 to mark as a trainer activity.
     * @param {number} [commute] Set to 1 to mark as commute.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public createActivity(name: string, type: string, startDateLocal: string, elapsedTime: number, description?: string, distance?: number, trainer?: number, commute?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).createActivity(name, type, startDateLocal, elapsedTime, description, distance, trainer, commute, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the given activity that is owned by the authenticated athlete. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity
     * @param {number} id The identifier of the activity.
     * @param {boolean} [includeAllEfforts] To include all segments efforts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getActivityById(id: number, includeAllEfforts?: boolean, options?: any) {
        return ActivitiesApiFp(this.configuration).getActivityById(id, includeAllEfforts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the comments on the given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Comments
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getCommentsByActivityId(id: number, page?: number, perPage?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getCommentsByActivityId(id, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the athletes who kudoed an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Kudoers
     * @param {number} id The identifier of the activity.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getKudoersByActivityId(id: number, page?: number, perPage?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getKudoersByActivityId(id, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the laps of an activity identified by an identifier. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary List Activity Laps
     * @param {number} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getLapsByActivityId(id: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getLapsByActivityId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the activities of an athlete for a specific identifier. Requires activity:read. Only Me activities will be filtered out unless requested by a token with activity:read_all.
     * @summary List Athlete Activities
     * @param {number} [before] An epoch timestamp to use for filtering activities that have taken place before a certain time.
     * @param {number} [after] An epoch timestamp to use for filtering activities that have taken place after a certain time.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getLoggedInAthleteActivities(before?: number, after?: number, page?: number, perPage?: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getLoggedInAthleteActivities(before, after, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Summit Feature. Returns the zones of a given activity. Requires activity:read for Everyone and Followers activities. Requires activity:read_all for Only Me activities.
     * @summary Get Activity Zones
     * @param {number} id The identifier of the activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public getZonesByActivityId(id: number, options?: any) {
        return ActivitiesApiFp(this.configuration).getZonesByActivityId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the given activity that is owned by the authenticated athlete. Requires activity:write. Also requires activity:read_all in order to update Only Me activities
     * @summary Update Activity
     * @param {number} id The identifier of the activity.
     * @param {UpdatableActivity} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActivitiesApi
     */
    public updateActivityById(id: number, body?: UpdatableActivity, options?: any) {
        return ActivitiesApiFp(this.configuration).updateActivityById(id, body, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * AthletesApi - axios parameter creator
 * @export
 */
export const AthletesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthlete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/athlete`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the the authenticated athlete\'s heart rate and power zones. Requires profile:read_all.
         * @summary Get Zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteZones: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/athlete/zones`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStats.');
            }
            const localVarPath = `/athletes/{id}/stats`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the currently authenticated athlete. Requires profile:write scope.
         * @summary Update Athlete
         * @param {number} weight The weight of the athlete in kilograms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggedInAthlete: async (weight: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'weight' is not null or undefined
            if (weight === null || weight === undefined) {
                throw new RequiredError('weight','Required parameter weight was null or undefined when calling updateLoggedInAthlete.');
            }
            const localVarPath = `/athlete`
                .replace(`{${"weight"}}`, encodeURIComponent(String(weight)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AthletesApi - functional programming interface
 * @export
 */
export const AthletesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggedInAthlete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedAthlete>> {
            const localVarAxiosArgs = await AthletesApiAxiosParamCreator(configuration).getLoggedInAthlete(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the the authenticated athlete\'s heart rate and power zones. Requires profile:read_all.
         * @summary Get Zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggedInAthleteZones(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zones>> {
            const localVarAxiosArgs = await AthletesApiAxiosParamCreator(configuration).getLoggedInAthleteZones(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStats(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ActivityStats>> {
            const localVarAxiosArgs = await AthletesApiAxiosParamCreator(configuration).getStats(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update the currently authenticated athlete. Requires profile:write scope.
         * @summary Update Athlete
         * @param {number} weight The weight of the athlete in kilograms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLoggedInAthlete(weight: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedAthlete>> {
            const localVarAxiosArgs = await AthletesApiAxiosParamCreator(configuration).updateLoggedInAthlete(weight, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AthletesApi - factory interface
 * @export
 */
export const AthletesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
         * @summary Get Authenticated Athlete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthlete(options?: any): AxiosPromise<DetailedAthlete> {
            return AthletesApiFp(configuration).getLoggedInAthlete(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the the authenticated athlete\'s heart rate and power zones. Requires profile:read_all.
         * @summary Get Zones
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteZones(options?: any): AxiosPromise<Zones> {
            return AthletesApiFp(configuration).getLoggedInAthleteZones(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
         * @summary Get Athlete Stats
         * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStats(id: number, options?: any): AxiosPromise<ActivityStats> {
            return AthletesApiFp(configuration).getStats(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the currently authenticated athlete. Requires profile:write scope.
         * @summary Update Athlete
         * @param {number} weight The weight of the athlete in kilograms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLoggedInAthlete(weight: number, options?: any): AxiosPromise<DetailedAthlete> {
            return AthletesApiFp(configuration).updateLoggedInAthlete(weight, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AthletesApi - object-oriented interface
 * @export
 * @class AthletesApi
 * @extends {BaseAPI}
 */
export class AthletesApi extends BaseAPI {
    /**
     * Returns the currently authenticated athlete. Tokens with profile:read_all scope will receive a detailed athlete representation; all others will receive a summary representation.
     * @summary Get Authenticated Athlete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public getLoggedInAthlete(options?: any) {
        return AthletesApiFp(this.configuration).getLoggedInAthlete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the the authenticated athlete\'s heart rate and power zones. Requires profile:read_all.
     * @summary Get Zones
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public getLoggedInAthleteZones(options?: any) {
        return AthletesApiFp(this.configuration).getLoggedInAthleteZones(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the activity stats of an athlete. Only includes data from activities set to Everyone visibilty.
     * @summary Get Athlete Stats
     * @param {number} id The identifier of the athlete. Must match the authenticated athlete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public getStats(id: number, options?: any) {
        return AthletesApiFp(this.configuration).getStats(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the currently authenticated athlete. Requires profile:write scope.
     * @summary Update Athlete
     * @param {number} weight The weight of the athlete in kilograms.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AthletesApi
     */
    public updateLoggedInAthlete(weight: number, options?: any) {
        return AthletesApiFp(this.configuration).updateLoggedInAthlete(weight, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ClubsApi - axios parameter creator
 * @export
 */
export const ClubsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
         * @summary List Club Activities
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubActivitiesById: async (id: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClubActivitiesById.');
            }
            const localVarPath = `/clubs/{id}/activities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the administrators of a given club.
         * @summary List Club Administrators
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubAdminsById: async (id: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClubAdminsById.');
            }
            const localVarPath = `/clubs/{id}/admins`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a given club using its identifier.
         * @summary Get Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClubById.');
            }
            const localVarPath = `/clubs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the athletes who are members of a given club.
         * @summary List Club Members
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubMembersById: async (id: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getClubMembersById.');
            }
            const localVarPath = `/clubs/{id}/members`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the clubs whose membership includes the authenticated athlete.
         * @summary List Athlete Clubs
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteClubs: async (page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/athlete/clubs`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClubsApi - functional programming interface
 * @export
 */
export const ClubsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
         * @summary List Club Activities
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClubActivitiesById(id: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummaryActivity>>> {
            const localVarAxiosArgs = await ClubsApiAxiosParamCreator(configuration).getClubActivitiesById(id, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of the administrators of a given club.
         * @summary List Club Administrators
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClubAdminsById(id: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummaryAthlete>>> {
            const localVarAxiosArgs = await ClubsApiAxiosParamCreator(configuration).getClubAdminsById(id, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a given club using its identifier.
         * @summary Get Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClubById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedClub>> {
            const localVarAxiosArgs = await ClubsApiAxiosParamCreator(configuration).getClubById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of the athletes who are members of a given club.
         * @summary List Club Members
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClubMembersById(id: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummaryAthlete>>> {
            const localVarAxiosArgs = await ClubsApiAxiosParamCreator(configuration).getClubMembersById(id, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of the clubs whose membership includes the authenticated athlete.
         * @summary List Athlete Clubs
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggedInAthleteClubs(page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummaryClub>>> {
            const localVarAxiosArgs = await ClubsApiAxiosParamCreator(configuration).getLoggedInAthleteClubs(page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ClubsApi - factory interface
 * @export
 */
export const ClubsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
         * @summary List Club Activities
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubActivitiesById(id: number, page?: number, perPage?: number, options?: any): AxiosPromise<Array<SummaryActivity>> {
            return ClubsApiFp(configuration).getClubActivitiesById(id, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the administrators of a given club.
         * @summary List Club Administrators
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubAdminsById(id: number, page?: number, perPage?: number, options?: any): AxiosPromise<Array<SummaryAthlete>> {
            return ClubsApiFp(configuration).getClubAdminsById(id, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a given club using its identifier.
         * @summary Get Club
         * @param {number} id The identifier of the club.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubById(id: number, options?: any): AxiosPromise<DetailedClub> {
            return ClubsApiFp(configuration).getClubById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the athletes who are members of a given club.
         * @summary List Club Members
         * @param {number} id The identifier of the club.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClubMembersById(id: number, page?: number, perPage?: number, options?: any): AxiosPromise<Array<SummaryAthlete>> {
            return ClubsApiFp(configuration).getClubMembersById(id, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the clubs whose membership includes the authenticated athlete.
         * @summary List Athlete Clubs
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteClubs(page?: number, perPage?: number, options?: any): AxiosPromise<Array<SummaryClub>> {
            return ClubsApiFp(configuration).getLoggedInAthleteClubs(page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClubsApi - object-oriented interface
 * @export
 * @class ClubsApi
 * @extends {BaseAPI}
 */
export class ClubsApi extends BaseAPI {
    /**
     * Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
     * @summary List Club Activities
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubActivitiesById(id: number, page?: number, perPage?: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubActivitiesById(id, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the administrators of a given club.
     * @summary List Club Administrators
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubAdminsById(id: number, page?: number, perPage?: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubAdminsById(id, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a given club using its identifier.
     * @summary Get Club
     * @param {number} id The identifier of the club.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubById(id: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the athletes who are members of a given club.
     * @summary List Club Members
     * @param {number} id The identifier of the club.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getClubMembersById(id: number, page?: number, perPage?: number, options?: any) {
        return ClubsApiFp(this.configuration).getClubMembersById(id, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the clubs whose membership includes the authenticated athlete.
     * @summary List Athlete Clubs
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClubsApi
     */
    public getLoggedInAthleteClubs(page?: number, perPage?: number, options?: any) {
        return ClubsApiFp(this.configuration).getLoggedInAthleteClubs(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * GearsApi - axios parameter creator
 * @export
 */
export const GearsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns an equipment using its identifier.
         * @summary Get Equipment
         * @param {string} id The identifier of the gear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearById: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getGearById.');
            }
            const localVarPath = `/gear/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GearsApi - functional programming interface
 * @export
 */
export const GearsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns an equipment using its identifier.
         * @summary Get Equipment
         * @param {string} id The identifier of the gear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGearById(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedGear>> {
            const localVarAxiosArgs = await GearsApiAxiosParamCreator(configuration).getGearById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GearsApi - factory interface
 * @export
 */
export const GearsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns an equipment using its identifier.
         * @summary Get Equipment
         * @param {string} id The identifier of the gear.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGearById(id: string, options?: any): AxiosPromise<DetailedGear> {
            return GearsApiFp(configuration).getGearById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GearsApi - object-oriented interface
 * @export
 * @class GearsApi
 * @extends {BaseAPI}
 */
export class GearsApi extends BaseAPI {
    /**
     * Returns an equipment using its identifier.
     * @summary Get Equipment
     * @param {string} id The identifier of the gear.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GearsApi
     */
    public getGearById(id: string, options?: any) {
        return GearsApiFp(this.configuration).getGearById(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RoutesApi - axios parameter creator
 * @export
 */
export const RoutesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a GPX file of the route. Requires read_all scope for private routes.
         * @summary Export Route GPX
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAsGPX: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRouteAsGPX.');
            }
            const localVarPath = `/routes/{id}/export_gpx`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a TCX file of the route. Requires read_all scope for private routes.
         * @summary Export Route TCX
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAsTCX: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRouteAsTCX.');
            }
            const localVarPath = `/routes/{id}/export_tcx`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a route using its identifier. Requires read_all scope for private routes.
         * @summary Get Route
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRouteById.');
            }
            const localVarPath = `/routes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of the routes created by the authenticated athlete using their athlete ID. Private routes are filtered out unless requested by a token with read_all scope.
         * @summary List Athlete Routes
         * @param {number} id The identifier of the athlete.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesByAthleteId: async (id: number, page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRoutesByAthleteId.');
            }
            const localVarPath = `/athletes/{id}/routes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutesApi - functional programming interface
 * @export
 */
export const RoutesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a GPX file of the route. Requires read_all scope for private routes.
         * @summary Export Route GPX
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAsGPX(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).getRouteAsGPX(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a TCX file of the route. Requires read_all scope for private routes.
         * @summary Export Route TCX
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteAsTCX(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).getRouteAsTCX(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a route using its identifier. Requires read_all scope for private routes.
         * @summary Get Route
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Route>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).getRouteById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list of the routes created by the authenticated athlete using their athlete ID. Private routes are filtered out unless requested by a token with read_all scope.
         * @summary List Athlete Routes
         * @param {number} id The identifier of the athlete.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoutesByAthleteId(id: number, page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Route>>> {
            const localVarAxiosArgs = await RoutesApiAxiosParamCreator(configuration).getRoutesByAthleteId(id, page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RoutesApi - factory interface
 * @export
 */
export const RoutesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a GPX file of the route. Requires read_all scope for private routes.
         * @summary Export Route GPX
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAsGPX(id: number, options?: any): AxiosPromise<void> {
            return RoutesApiFp(configuration).getRouteAsGPX(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a TCX file of the route. Requires read_all scope for private routes.
         * @summary Export Route TCX
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteAsTCX(id: number, options?: any): AxiosPromise<void> {
            return RoutesApiFp(configuration).getRouteAsTCX(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a route using its identifier. Requires read_all scope for private routes.
         * @summary Get Route
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteById(id: number, options?: any): AxiosPromise<Route> {
            return RoutesApiFp(configuration).getRouteById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of the routes created by the authenticated athlete using their athlete ID. Private routes are filtered out unless requested by a token with read_all scope.
         * @summary List Athlete Routes
         * @param {number} id The identifier of the athlete.
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoutesByAthleteId(id: number, page?: number, perPage?: number, options?: any): AxiosPromise<Array<Route>> {
            return RoutesApiFp(configuration).getRoutesByAthleteId(id, page, perPage, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutesApi - object-oriented interface
 * @export
 * @class RoutesApi
 * @extends {BaseAPI}
 */
export class RoutesApi extends BaseAPI {
    /**
     * Returns a GPX file of the route. Requires read_all scope for private routes.
     * @summary Export Route GPX
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRouteAsGPX(id: number, options?: any) {
        return RoutesApiFp(this.configuration).getRouteAsGPX(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a TCX file of the route. Requires read_all scope for private routes.
     * @summary Export Route TCX
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRouteAsTCX(id: number, options?: any) {
        return RoutesApiFp(this.configuration).getRouteAsTCX(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a route using its identifier. Requires read_all scope for private routes.
     * @summary Get Route
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRouteById(id: number, options?: any) {
        return RoutesApiFp(this.configuration).getRouteById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of the routes created by the authenticated athlete using their athlete ID. Private routes are filtered out unless requested by a token with read_all scope.
     * @summary List Athlete Routes
     * @param {number} id The identifier of the athlete.
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutesApi
     */
    public getRoutesByAthleteId(id: number, page?: number, perPage?: number, options?: any) {
        return RoutesApiFp(this.configuration).getRoutesByAthleteId(id, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RunningRacesApi - axios parameter creator
 * @export
 */
export const RunningRacesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a running race for a given identifier.
         * @summary Get Running Race
         * @param {number} id The identifier of the running race.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaceById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRunningRaceById.');
            }
            const localVarPath = `/running_races/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list running races based on a set of search criteria.
         * @summary List Running Races
         * @param {number} [year] Filters the list by a given year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaces: async (year?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/running_races`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RunningRacesApi - functional programming interface
 * @export
 */
export const RunningRacesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a running race for a given identifier.
         * @summary Get Running Race
         * @param {number} id The identifier of the running race.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunningRaceById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RunningRace>> {
            const localVarAxiosArgs = await RunningRacesApiAxiosParamCreator(configuration).getRunningRaceById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a list running races based on a set of search criteria.
         * @summary List Running Races
         * @param {number} [year] Filters the list by a given year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRunningRaces(year?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RunningRace>>> {
            const localVarAxiosArgs = await RunningRacesApiAxiosParamCreator(configuration).getRunningRaces(year, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RunningRacesApi - factory interface
 * @export
 */
export const RunningRacesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a running race for a given identifier.
         * @summary Get Running Race
         * @param {number} id The identifier of the running race.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaceById(id: number, options?: any): AxiosPromise<RunningRace> {
            return RunningRacesApiFp(configuration).getRunningRaceById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list running races based on a set of search criteria.
         * @summary List Running Races
         * @param {number} [year] Filters the list by a given year.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRunningRaces(year?: number, options?: any): AxiosPromise<Array<RunningRace>> {
            return RunningRacesApiFp(configuration).getRunningRaces(year, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RunningRacesApi - object-oriented interface
 * @export
 * @class RunningRacesApi
 * @extends {BaseAPI}
 */
export class RunningRacesApi extends BaseAPI {
    /**
     * Returns a running race for a given identifier.
     * @summary Get Running Race
     * @param {number} id The identifier of the running race.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunningRacesApi
     */
    public getRunningRaceById(id: number, options?: any) {
        return RunningRacesApiFp(this.configuration).getRunningRaceById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list running races based on a set of search criteria.
     * @summary List Running Races
     * @param {number} [year] Filters the list by a given year.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RunningRacesApi
     */
    public getRunningRaces(year?: number, options?: any) {
        return RunningRacesApiFp(this.configuration).getRunningRaces(year, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SegmentEffortsApi - axios parameter creator
 * @export
 */
export const SegmentEffortsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a set of the authenticated athlete\'s segment efforts for a given segment.  Requires subscription.
         * @summary List Segment Efforts
         * @param {number} segmentId The identifier of the segment.
         * @param {string} [startDateLocal] ISO 8601 formatted date time.
         * @param {string} [endDateLocal] ISO 8601 formatted date time.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffortsBySegmentId: async (segmentId: number, startDateLocal?: string, endDateLocal?: string, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'segmentId' is not null or undefined
            if (segmentId === null || segmentId === undefined) {
                throw new RequiredError('segmentId','Required parameter segmentId was null or undefined when calling getEffortsBySegmentId.');
            }
            const localVarPath = `/segment_efforts`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (segmentId !== undefined) {
                localVarQueryParameter['segment_id'] = segmentId;
            }

            if (startDateLocal !== undefined) {
                localVarQueryParameter['start_date_local'] = (startDateLocal as any instanceof Date) ?
                    (startDateLocal as any).toISOString() :
                    startDateLocal;
            }

            if (endDateLocal !== undefined) {
                localVarQueryParameter['end_date_local'] = (endDateLocal as any instanceof Date) ?
                    (endDateLocal as any).toISOString() :
                    endDateLocal;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
         * @summary Get Segment Effort
         * @param {number} id The identifier of the segment effort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSegmentEffortById.');
            }
            const localVarPath = `/segment_efforts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentEffortsApi - functional programming interface
 * @export
 */
export const SegmentEffortsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a set of the authenticated athlete\'s segment efforts for a given segment.  Requires subscription.
         * @summary List Segment Efforts
         * @param {number} segmentId The identifier of the segment.
         * @param {string} [startDateLocal] ISO 8601 formatted date time.
         * @param {string} [endDateLocal] ISO 8601 formatted date time.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEffortsBySegmentId(segmentId: number, startDateLocal?: string, endDateLocal?: string, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DetailedSegmentEffort>>> {
            const localVarAxiosArgs = await SegmentEffortsApiAxiosParamCreator(configuration).getEffortsBySegmentId(segmentId, startDateLocal, endDateLocal, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
         * @summary Get Segment Effort
         * @param {number} id The identifier of the segment effort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentEffortById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedSegmentEffort>> {
            const localVarAxiosArgs = await SegmentEffortsApiAxiosParamCreator(configuration).getSegmentEffortById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SegmentEffortsApi - factory interface
 * @export
 */
export const SegmentEffortsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a set of the authenticated athlete\'s segment efforts for a given segment.  Requires subscription.
         * @summary List Segment Efforts
         * @param {number} segmentId The identifier of the segment.
         * @param {string} [startDateLocal] ISO 8601 formatted date time.
         * @param {string} [endDateLocal] ISO 8601 formatted date time.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEffortsBySegmentId(segmentId: number, startDateLocal?: string, endDateLocal?: string, perPage?: number, options?: any): AxiosPromise<Array<DetailedSegmentEffort>> {
            return SegmentEffortsApiFp(configuration).getEffortsBySegmentId(segmentId, startDateLocal, endDateLocal, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
         * @summary Get Segment Effort
         * @param {number} id The identifier of the segment effort.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortById(id: number, options?: any): AxiosPromise<DetailedSegmentEffort> {
            return SegmentEffortsApiFp(configuration).getSegmentEffortById(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentEffortsApi - object-oriented interface
 * @export
 * @class SegmentEffortsApi
 * @extends {BaseAPI}
 */
export class SegmentEffortsApi extends BaseAPI {
    /**
     * Returns a set of the authenticated athlete\'s segment efforts for a given segment.  Requires subscription.
     * @summary List Segment Efforts
     * @param {number} segmentId The identifier of the segment.
     * @param {string} [startDateLocal] ISO 8601 formatted date time.
     * @param {string} [endDateLocal] ISO 8601 formatted date time.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentEffortsApi
     */
    public getEffortsBySegmentId(segmentId: number, startDateLocal?: string, endDateLocal?: string, perPage?: number, options?: any) {
        return SegmentEffortsApiFp(this.configuration).getEffortsBySegmentId(segmentId, startDateLocal, endDateLocal, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a segment effort from an activity that is owned by the authenticated athlete. Requires subscription.
     * @summary Get Segment Effort
     * @param {number} id The identifier of the segment effort.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentEffortsApi
     */
    public getSegmentEffortById(id: number, options?: any) {
        return SegmentEffortsApiFp(this.configuration).getSegmentEffortById(id, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the top 10 segments matching a specified query.
         * @summary Explore segments
         * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
         * @param {'running' | 'riding'} [activityType] Desired activity type.
         * @param {number} [minCat] The minimum climbing category.
         * @param {number} [maxCat] The maximum climbing category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreSegments: async (bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bounds' is not null or undefined
            if (bounds === null || bounds === undefined) {
                throw new RequiredError('bounds','Required parameter bounds was null or undefined when calling exploreSegments.');
            }
            const localVarPath = `/segments/explore`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (bounds) {
                localVarQueryParameter['bounds'] = bounds.join(COLLECTION_FORMATS.csv);
            }

            if (activityType !== undefined) {
                localVarQueryParameter['activity_type'] = activityType;
            }

            if (minCat !== undefined) {
                localVarQueryParameter['min_cat'] = minCat;
            }

            if (maxCat !== undefined) {
                localVarQueryParameter['max_cat'] = maxCat;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of the authenticated athlete\'s starred segments. Private segments are filtered out unless requested by a token with read_all scope.
         * @summary List Starred Segments
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteStarredSegments: async (page?: number, perPage?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/segments/starred`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['per_page'] = perPage;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
         * @summary Get Segment
         * @param {number} id The identifier of the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentById: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSegmentById.');
            }
            const localVarPath = `/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
         * @summary Star Segment
         * @param {number} id The identifier of the segment to star.
         * @param {boolean} starred If true, star the segment; if false, unstar the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starSegment: async (id: number, starred: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling starSegment.');
            }
            // verify required parameter 'starred' is not null or undefined
            if (starred === null || starred === undefined) {
                throw new RequiredError('starred','Required parameter starred was null or undefined when calling starSegment.');
            }
            const localVarPath = `/segments/{id}/starred`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


            if (starred !== undefined) { 
                localVarFormParams.append('starred', starred as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the top 10 segments matching a specified query.
         * @summary Explore segments
         * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
         * @param {'running' | 'riding'} [activityType] Desired activity type.
         * @param {number} [minCat] The minimum climbing category.
         * @param {number} [maxCat] The maximum climbing category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exploreSegments(bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExplorerResponse>> {
            const localVarAxiosArgs = await SegmentsApiAxiosParamCreator(configuration).exploreSegments(bounds, activityType, minCat, maxCat, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List of the authenticated athlete\'s starred segments. Private segments are filtered out unless requested by a token with read_all scope.
         * @summary List Starred Segments
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLoggedInAthleteStarredSegments(page?: number, perPage?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SummarySegment>>> {
            const localVarAxiosArgs = await SegmentsApiAxiosParamCreator(configuration).getLoggedInAthleteStarredSegments(page, perPage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
         * @summary Get Segment
         * @param {number} id The identifier of the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentById(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedSegment>> {
            const localVarAxiosArgs = await SegmentsApiAxiosParamCreator(configuration).getSegmentById(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
         * @summary Star Segment
         * @param {number} id The identifier of the segment to star.
         * @param {boolean} starred If true, star the segment; if false, unstar the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async starSegment(id: number, starred: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DetailedSegment>> {
            const localVarAxiosArgs = await SegmentsApiAxiosParamCreator(configuration).starSegment(id, starred, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the top 10 segments matching a specified query.
         * @summary Explore segments
         * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
         * @param {'running' | 'riding'} [activityType] Desired activity type.
         * @param {number} [minCat] The minimum climbing category.
         * @param {number} [maxCat] The maximum climbing category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exploreSegments(bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number, options?: any): AxiosPromise<ExplorerResponse> {
            return SegmentsApiFp(configuration).exploreSegments(bounds, activityType, minCat, maxCat, options).then((request) => request(axios, basePath));
        },
        /**
         * List of the authenticated athlete\'s starred segments. Private segments are filtered out unless requested by a token with read_all scope.
         * @summary List Starred Segments
         * @param {number} [page] Page number. Defaults to 1.
         * @param {number} [perPage] Number of items per page. Defaults to 30.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLoggedInAthleteStarredSegments(page?: number, perPage?: number, options?: any): AxiosPromise<Array<SummarySegment>> {
            return SegmentsApiFp(configuration).getLoggedInAthleteStarredSegments(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
         * @summary Get Segment
         * @param {number} id The identifier of the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentById(id: number, options?: any): AxiosPromise<DetailedSegment> {
            return SegmentsApiFp(configuration).getSegmentById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
         * @summary Star Segment
         * @param {number} id The identifier of the segment to star.
         * @param {boolean} starred If true, star the segment; if false, unstar the segment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        starSegment(id: number, starred: boolean, options?: any): AxiosPromise<DetailedSegment> {
            return SegmentsApiFp(configuration).starSegment(id, starred, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * Returns the top 10 segments matching a specified query.
     * @summary Explore segments
     * @param {Array<number>} bounds The latitude and longitude for two points describing a rectangular boundary for the search: [southwest corner latitutde, southwest corner longitude, northeast corner latitude, northeast corner longitude]
     * @param {'running' | 'riding'} [activityType] Desired activity type.
     * @param {number} [minCat] The minimum climbing category.
     * @param {number} [maxCat] The maximum climbing category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public exploreSegments(bounds: Array<number>, activityType?: 'running' | 'riding', minCat?: number, maxCat?: number, options?: any) {
        return SegmentsApiFp(this.configuration).exploreSegments(bounds, activityType, minCat, maxCat, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List of the authenticated athlete\'s starred segments. Private segments are filtered out unless requested by a token with read_all scope.
     * @summary List Starred Segments
     * @param {number} [page] Page number. Defaults to 1.
     * @param {number} [perPage] Number of items per page. Defaults to 30.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getLoggedInAthleteStarredSegments(page?: number, perPage?: number, options?: any) {
        return SegmentsApiFp(this.configuration).getLoggedInAthleteStarredSegments(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the specified segment. read_all scope required in order to retrieve athlete-specific segment information, or to retrieve private segments.
     * @summary Get Segment
     * @param {number} id The identifier of the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public getSegmentById(id: number, options?: any) {
        return SegmentsApiFp(this.configuration).getSegmentById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stars/Unstars the given segment for the authenticated athlete. Requires profile:write scope.
     * @summary Star Segment
     * @param {number} id The identifier of the segment to star.
     * @param {boolean} starred If true, star the segment; if false, unstar the segment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public starSegment(id: number, starred: boolean, options?: any) {
        return SegmentsApiFp(this.configuration).starSegment(id, starred, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StreamsApi - axios parameter creator
 * @export
 */
export const StreamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the given activity\'s streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
         * @summary Get Activity Streams
         * @param {number} id The identifier of the activity.
         * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStreams: async (id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivityStreams.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling getActivityStreams.');
            }
            // verify required parameter 'keyByType' is not null or undefined
            if (keyByType === null || keyByType === undefined) {
                throw new RequiredError('keyByType','Required parameter keyByType was null or undefined when calling getActivityStreams.');
            }
            const localVarPath = `/activities/{id}/streams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (keys) {
                localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS.csv);
            }

            if (keyByType !== undefined) {
                localVarQueryParameter['key_by_type'] = keyByType;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the given route\'s streams. Requires read_all scope for private routes.
         * @summary Get Route Streams
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteStreams: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRouteStreams.');
            }
            const localVarPath = `/routes/{id}/streams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
         * @summary Get Segment Effort Streams
         * @param {number} id The identifier of the segment effort.
         * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortStreams: async (id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSegmentEffortStreams.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling getSegmentEffortStreams.');
            }
            // verify required parameter 'keyByType' is not null or undefined
            if (keyByType === null || keyByType === undefined) {
                throw new RequiredError('keyByType','Required parameter keyByType was null or undefined when calling getSegmentEffortStreams.');
            }
            const localVarPath = `/segment_efforts/{id}/streams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (keys) {
                localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS.csv);
            }

            if (keyByType !== undefined) {
                localVarQueryParameter['key_by_type'] = keyByType;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the given segment\'s streams. Requires read_all scope for private segments.
         * @summary Get Segment Streams
         * @param {number} id The identifier of the segment.
         * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentStreams: async (id: number, keys: Array<'distance' | 'latlng' | 'altitude'>, keyByType: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getSegmentStreams.');
            }
            // verify required parameter 'keys' is not null or undefined
            if (keys === null || keys === undefined) {
                throw new RequiredError('keys','Required parameter keys was null or undefined when calling getSegmentStreams.');
            }
            // verify required parameter 'keyByType' is not null or undefined
            if (keyByType === null || keyByType === undefined) {
                throw new RequiredError('keyByType','Required parameter keyByType was null or undefined when calling getSegmentStreams.');
            }
            const localVarPath = `/segments/{id}/streams`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            if (keys) {
                localVarQueryParameter['keys'] = keys.join(COLLECTION_FORMATS.csv);
            }

            if (keyByType !== undefined) {
                localVarQueryParameter['key_by_type'] = keyByType;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns the given activity\'s streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
         * @summary Get Activity Streams
         * @param {number} id The identifier of the activity.
         * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getActivityStreams(id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSet>> {
            const localVarAxiosArgs = await StreamsApiAxiosParamCreator(configuration).getActivityStreams(id, keys, keyByType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the given route\'s streams. Requires read_all scope for private routes.
         * @summary Get Route Streams
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRouteStreams(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSet>> {
            const localVarAxiosArgs = await StreamsApiAxiosParamCreator(configuration).getRouteStreams(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
         * @summary Get Segment Effort Streams
         * @param {number} id The identifier of the segment effort.
         * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentEffortStreams(id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSet>> {
            const localVarAxiosArgs = await StreamsApiAxiosParamCreator(configuration).getSegmentEffortStreams(id, keys, keyByType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns the given segment\'s streams. Requires read_all scope for private segments.
         * @summary Get Segment Streams
         * @param {number} id The identifier of the segment.
         * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSegmentStreams(id: number, keys: Array<'distance' | 'latlng' | 'altitude'>, keyByType: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StreamSet>> {
            const localVarAxiosArgs = await StreamsApiAxiosParamCreator(configuration).getSegmentStreams(id, keys, keyByType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns the given activity\'s streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
         * @summary Get Activity Streams
         * @param {number} id The identifier of the activity.
         * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStreams(id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean, options?: any): AxiosPromise<StreamSet> {
            return StreamsApiFp(configuration).getActivityStreams(id, keys, keyByType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the given route\'s streams. Requires read_all scope for private routes.
         * @summary Get Route Streams
         * @param {number} id The identifier of the route.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRouteStreams(id: number, options?: any): AxiosPromise<StreamSet> {
            return StreamsApiFp(configuration).getRouteStreams(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
         * @summary Get Segment Effort Streams
         * @param {number} id The identifier of the segment effort.
         * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentEffortStreams(id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean, options?: any): AxiosPromise<StreamSet> {
            return StreamsApiFp(configuration).getSegmentEffortStreams(id, keys, keyByType, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the given segment\'s streams. Requires read_all scope for private segments.
         * @summary Get Segment Streams
         * @param {number} id The identifier of the segment.
         * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
         * @param {boolean} keyByType Must be true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSegmentStreams(id: number, keys: Array<'distance' | 'latlng' | 'altitude'>, keyByType: boolean, options?: any): AxiosPromise<StreamSet> {
            return StreamsApiFp(configuration).getSegmentStreams(id, keys, keyByType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
    /**
     * Returns the given activity\'s streams. Requires activity:read scope. Requires activity:read_all scope for Only Me activities.
     * @summary Get Activity Streams
     * @param {number} id The identifier of the activity.
     * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys Desired stream types.
     * @param {boolean} keyByType Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getActivityStreams(id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean, options?: any) {
        return StreamsApiFp(this.configuration).getActivityStreams(id, keys, keyByType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the given route\'s streams. Requires read_all scope for private routes.
     * @summary Get Route Streams
     * @param {number} id The identifier of the route.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getRouteStreams(id: number, options?: any) {
        return StreamsApiFp(this.configuration).getRouteStreams(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a set of streams for a segment effort completed by the authenticated athlete. Requires read_all scope.
     * @summary Get Segment Effort Streams
     * @param {number} id The identifier of the segment effort.
     * @param {Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>} keys The types of streams to return.
     * @param {boolean} keyByType Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getSegmentEffortStreams(id: number, keys: Array<'time' | 'distance' | 'latlng' | 'altitude' | 'velocity_smooth' | 'heartrate' | 'cadence' | 'watts' | 'temp' | 'moving' | 'grade_smooth'>, keyByType: boolean, options?: any) {
        return StreamsApiFp(this.configuration).getSegmentEffortStreams(id, keys, keyByType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the given segment\'s streams. Requires read_all scope for private segments.
     * @summary Get Segment Streams
     * @param {number} id The identifier of the segment.
     * @param {Array<'distance' | 'latlng' | 'altitude'>} keys The types of streams to return.
     * @param {boolean} keyByType Must be true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public getSegmentStreams(id: number, keys: Array<'distance' | 'latlng' | 'altitude'>, keyByType: boolean, options?: any) {
        return StreamsApiFp(this.configuration).getSegmentStreams(id, keys, keyByType, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * UploadsApi - axios parameter creator
 * @export
 */
export const UploadsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Uploads a new data file to create an activity from. Requires activity:write scope.
         * @summary Upload Activity
         * @param {any} [file] The uploaded file.
         * @param {string} [name] The desired name of the resulting activity.
         * @param {string} [description] The desired description of the resulting activity.
         * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
         * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
         * @param {string} [dataType] The format of the uploaded file.
         * @param {string} [externalId] The desired external identifier of the resulting activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload: async (file?: any, name?: string, description?: string, trainer?: string, commute?: string, dataType?: string, externalId?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/uploads`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (trainer !== undefined) { 
                localVarFormParams.append('trainer', trainer as any);
            }
    
            if (commute !== undefined) { 
                localVarFormParams.append('commute', commute as any);
            }
    
            if (dataType !== undefined) { 
                localVarFormParams.append('data_type', dataType as any);
            }
    
            if (externalId !== undefined) { 
                localVarFormParams.append('external_id', externalId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an upload for a given identifier. Requires activity:write scope.
         * @summary Get Upload
         * @param {number} uploadId The identifier of the upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadById: async (uploadId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'uploadId' is not null or undefined
            if (uploadId === null || uploadId === undefined) {
                throw new RequiredError('uploadId','Required parameter uploadId was null or undefined when calling getUploadById.');
            }
            const localVarPath = `/uploads/{uploadId}`
                .replace(`{${"uploadId"}}`, encodeURIComponent(String(uploadId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication strava_oauth required
            // oauth required
            if (configuration && configuration.accessToken) {
                const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken("strava_oauth", ["public"])
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadsApi - functional programming interface
 * @export
 */
export const UploadsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Uploads a new data file to create an activity from. Requires activity:write scope.
         * @summary Upload Activity
         * @param {any} [file] The uploaded file.
         * @param {string} [name] The desired name of the resulting activity.
         * @param {string} [description] The desired description of the resulting activity.
         * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
         * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
         * @param {string} [dataType] The format of the uploaded file.
         * @param {string} [externalId] The desired external identifier of the resulting activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUpload(file?: any, name?: string, description?: string, trainer?: string, commute?: string, dataType?: string, externalId?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Upload>> {
            const localVarAxiosArgs = await UploadsApiAxiosParamCreator(configuration).createUpload(file, name, description, trainer, commute, dataType, externalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns an upload for a given identifier. Requires activity:write scope.
         * @summary Get Upload
         * @param {number} uploadId The identifier of the upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUploadById(uploadId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Upload>> {
            const localVarAxiosArgs = await UploadsApiAxiosParamCreator(configuration).getUploadById(uploadId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UploadsApi - factory interface
 * @export
 */
export const UploadsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Uploads a new data file to create an activity from. Requires activity:write scope.
         * @summary Upload Activity
         * @param {any} [file] The uploaded file.
         * @param {string} [name] The desired name of the resulting activity.
         * @param {string} [description] The desired description of the resulting activity.
         * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
         * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
         * @param {string} [dataType] The format of the uploaded file.
         * @param {string} [externalId] The desired external identifier of the resulting activity.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUpload(file?: any, name?: string, description?: string, trainer?: string, commute?: string, dataType?: string, externalId?: string, options?: any): AxiosPromise<Upload> {
            return UploadsApiFp(configuration).createUpload(file, name, description, trainer, commute, dataType, externalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an upload for a given identifier. Requires activity:write scope.
         * @summary Get Upload
         * @param {number} uploadId The identifier of the upload.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUploadById(uploadId: number, options?: any): AxiosPromise<Upload> {
            return UploadsApiFp(configuration).getUploadById(uploadId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadsApi - object-oriented interface
 * @export
 * @class UploadsApi
 * @extends {BaseAPI}
 */
export class UploadsApi extends BaseAPI {
    /**
     * Uploads a new data file to create an activity from. Requires activity:write scope.
     * @summary Upload Activity
     * @param {any} [file] The uploaded file.
     * @param {string} [name] The desired name of the resulting activity.
     * @param {string} [description] The desired description of the resulting activity.
     * @param {string} [trainer] Whether the resulting activity should be marked as having been performed on a trainer.
     * @param {string} [commute] Whether the resulting activity should be tagged as a commute.
     * @param {string} [dataType] The format of the uploaded file.
     * @param {string} [externalId] The desired external identifier of the resulting activity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public createUpload(file?: any, name?: string, description?: string, trainer?: string, commute?: string, dataType?: string, externalId?: string, options?: any) {
        return UploadsApiFp(this.configuration).createUpload(file, name, description, trainer, commute, dataType, externalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns an upload for a given identifier. Requires activity:write scope.
     * @summary Get Upload
     * @param {number} uploadId The identifier of the upload.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadsApi
     */
    public getUploadById(uploadId: number, options?: any) {
        return UploadsApiFp(this.configuration).getUploadById(uploadId, options).then((request) => request(this.axios, this.basePath));
    }

}


